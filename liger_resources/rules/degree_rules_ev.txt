--replace(true);

//Nounmodifiers
#n MOD #m in_set #p PRED %p & #p TYPE %k & #n s:: #s ==>
#p GLUE lam(P,lam(X,merge(drs([],[rel(%k,'strip(%p)',X)]),app(P,X)))) : ((#s_e -o #s_t) -o (#s_e -o #s_t)) || noscope.


//Degree (gradable) adjectives
#x PREDLINK #a & #x s:: #y EV #z &
#a ATYPE 'predicative' & #a SEMTYPE 'degree' &
#a SUBJ #b s:: #c &
#a PRED %a &  #a s:: #s
==> & #s DEGREE #d & #s DEGREE-HOLDER #z & #s DEGREE-PRED #p &
#p GLUE lam(P,lam(D,lam(X,drs([],[rel(strip(%a),X,D)])))) : ((#s_v -o #s_t) -o (#d_d -o (#s_v -o #s_t))).

//This works
#x ADJUNCT #n in_set #a & #x s:: #y &
#a ATYPE 'attributive' & #a SEMTYPE 'degree' &
#a PRED %a & #a s:: #s
==> #s DEGREE #d & #s DEGREE-HOLDER #y & #s DEGREE-PRED #p &
#p GLUE lam(P,lam(D,lam(X,drs([],[rel(strip(%a),X,D)])))) : ((#s_e -o #s_t) -o (#d_d -o (#s_e -o #s_t))).


// Rules for positive uses
// attributive
#x ADJUNCT #n in_set #a & #x PRED %x &
#a ATYPE 'attributive' &
#a PRED %a & #a s:: #b DEGREE #d & #b DEGREE-HOLDER #e
==> #d GLUE lam(P,merge(drs([D],[]),merge(drs([],[eq(th_strip(%a)('strip(%x)'),D)]),app(P,D)))) : ((#d_d -o #e_t) -o #e_t) || noscope.

// predicative
#x PREDLINK #a & #x SUBJ #y PRED %x &
#a ATYPE 'predicative' &
#a PRED %a & #a s:: #b DEGREE #d & #b DEGREE-HOLDER #e
==> #d GLUE lam(P,merge(drs([D],[]),merge(drs([],[eq(th_strip(%a)('strip(%x)'),D)]),app(P,D)))) : ((#d_d -o #e_t) -o #e_t) || noscope.

//Rules for comparative uses
#a ATYPE %u & #a DEGREE 'comparative' & #a PRED %p &
#a s:: #b DEGREE #d & #b DEGREE-HOLDER #e & #b DEGREE-PRED #p &
#a ADJUNCT #f in_set #c OBL-COMP #m OBJ #n s:: #o
==>
#o DEGREE #x & #o DEGREE-HOLDER #y &
#d GLUE lam(P,lam(Q,lam(E,
		merge(drs([D:d],[]),merge(app(app(P,D),E),drs([],[not(merge(drs([V],[]),app(app(Q,D),V)))])))))) :
		((#d_d -o (#b_v -o #b_t)) -o ((#x_d -o (#y_v -o #m_t)) -o (#b_v -o #b_t))) || noscope &
#m GLUE lam(D,lam(E,drs([],[rel(strip(%p),E,D)]))) : (#x_d -o (#y_v -o #m_t)) &
#n GLUE lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg1,E,X)]))))) :
		((#y_v -o #m_t) -o (#o_e -o (#y_v -o #m_t))).

//Axioms

//Be equality axiom
#p PRED %p & strip(%p) == 'be' & #p PREDLINK #c s:: #s TYPE 'entity' ==>
#p AXIOM all(X,all(Y,all(Z,imp(and(be(X),and(arg1(X,Y),arg2(X,Z))),eq(Y,Z))))).

//Comparative axioms
#a ATYPE %u & #a DEGREE 'comparative' & #a PRED %p ==>
#a AXIOM all(X, all(Y, all(D:d, imp(and(arg1(X, Y), fast(X, D)), fast(Y, D))))).

#a ATYPE %u & #a DEGREE 'comparative' & #a PRED %p &
#a s:: #b DEGREE #d & #b DEGREE-HOLDER #e & #b DEGREE-PRED #p &
#a ADJUNCT #f in_set #c OBL-COMP #m OBJ #n s:: #o ==>
#a MONO #q & #q AXIOM all(X, all(Delta1:d, iff(strip(%p)(X, Delta1), all(Delta2:d, imp(lessEq(Delta2, Delta1), strip(%p)(X, Delta2)))))) &
#a CP #r & #r AXIOM all(X, all(Y, imp(some(D:d, and(strip(%p)(X, D), not(strip(%p)(Y, D)))), all(D2:d, imp(strip(%p)(Y, D2), strip(%p)(X, D2)))))) &
#a MAX #s & #s AXIOM all(X, some(Delta1:d, and(strip(%p)(X, Delta1), not(some(Delta2:d, and(greater(Delta2, Delta1), strip(%p)(X, Delta2))))))).

