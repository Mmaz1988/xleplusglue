--replace(true);

#a TNS-ASP #b & #a s:: #c SIT #d & #c TEMP-REF #e ==> & #e T-REF 'undefined'.

//Tier 1 rules
#a TNS-ASP #b TENSE 'past' & #a s:: #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'past'.
#a TNS-ASP #b TENSE 'pres' & #a s:: #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'pres'.
#a TNS-ASP #b TENSE 'fut' & #a s:: #c TEMP-REF #d & #d T-REF 'undefined' ==>  #d T-REF 'fut'.

//#a TNS-ASP #b TENSE 'pres' & #a s:: #c ==> #c TEMP-REF #d & #d T-REF 'pres' & #d EVAL #e & #e TIME 'now'.
//#a TNS-ASP #b TENSE 'fut' & #a s:: #c ==> #c TEMP-REF #d & #d T-REF 'fut' & #d EVAL #e & #e TIME 'now'.

//Tier 2 rules
//SOT rule
#a T-REF 'past' &
#a ^(TEMP-REF>s::>COMP) #b & #b !(s::>TEMP-REF) #c T-REF 'past' ==> #a T-REF 'non-future'.

//Present counterfactual
#a T-REF 'past' &
#a ^(TEMP-REF>s::>OBJ>in_set>ADJUNCT) #b & #b VTYPE 'modal' &
#b !(>TEMP-REF) #c T-REF 'pres'
==> #a T-REF 'non-past'.

//Aspect rules
#a TNS-ASP #b PROG '+_' & #a s:: #c ==> #c VIEWPOINT #d & #d ASPECT 'impv' & #d A-RESTR 'ongoing'.
#a TNS-ASP #b PROG '-_' & #a s:: #c ==> #c VIEWPOINT #d & #d ASPECT 'undefined'.
#a TNS-ASP #b TENSE %x & #b PROG '-_' & #a s:: #c VIEWPOINT #d ASPECT 'undefined' ==> #d ASPECT 'prv' & #d A-RESTR 'bounded'.
#a TNS-ASP #b PERF '+_' & #a s:: #c ==> #c ASP-TENSE #d & #d A-REF 'past'.

//Tier 2 aspect example
#a T-REF 'undefined' &
#a ^(TEMP-REF) #b ^(s::>XCOMP) #c & #c !(s::>TEMP-REF) #d EVAL #e &
#b VIEWPOINT #f ASPECT 'prv'
==>  #a T-REF 'future' & #a EVAL #d.

//Semantic interpretation

//Rules for interpreting grammatical aspect
#a s:: #b VIEWPOINT #c ==>
#c VAR #d & #c RESTR #e &
#c ASP-RESTR' #f.

#a s:: #b VIEWPOINT #c A-RESTR 'ongoing' &
#c VAR #d & #c RESTR #e &
#c ASP-RESTR' #f ==>
#f GLUE lam(S,lam(T,drs([],[rel(ongoing,T,S)]))) : (#d_s -o (#e_s -o #c_t)).

#a s:: #b VIEWPOINT #c A-RESTR 'bounded' &
#c VAR #d & #c RESTR #e &
#c ASP-RESTR' #f ==>
#f GLUE lam(S,lam(T,drs([],[rel(bounded,T,S)]))) : (#d_s -o (#e_s -o #c_t)).


#a s:: #b VIEWPOINT #c ASPECT 'impv' &
#c VAR #d & #c RESTR #e &
#b TEMP-REF #f &
#b SIT #g
 ==>  #c GLUE lam(M,lam(P,lam(S,drs([],[imp(merge(drs([Z],[]),app(app(M,S),Z)),app(P,Z))])))) : ((#d_s -o (#e_s -o #c_t)) -o ((#g_s -o #g_t) -o (#f_s -o #f_t))).

//prv closure -- fixed
#a s:: #b VIEWPOINT #c ASPECT 'prv' &
#c VAR #d & #c RESTR #e &
#b TEMP-REF #f &
#b SIT #g
 ==>  #c GLUE lam(M,lam(P,lam(S,merge(drs([Z],[]),merge(app(app(M,S),Z),app(P,Z)))))) : ((#d_s -o (#e_s -o #c_t)) -o ((#g_s -o #g_t) -o (#f_s -o #f_t))).

#a s:: #b VIEWPOINT #c ASPECT 'undefined' &
#b TEMP-REF #f &
#b SIT #g
 ==>  #c GLUE lam(P,lam(S,merge(drs([],[]),app(P,S)))) : ((#g_s -o #b_t) -o (#f_s -o #b_t)).

//Tense values

//Past reference
#a s:: #b TEMP-REF #c T-REF 'past' & #c EVAL #d ==>
#c T-REF' #e & #e GLUE lam(T,lam(T2,drs([],[rel(before,T,T2)]))) : (#c_s -o (#d_s -o #c_t)).

//Aspectual tense
#a s:: #b TEMP-REF #c EVAL #d &
#b ASP-TENSE #e A-REF 'past' &
 ==>
#e A-REF' #f & #f GLUE lam(T,lam(T2,drs([],[rel(before,T,T2)]))) :(#e_s -o (#c_s -o #e_t)) .

//Present reference
#a s:: #b TEMP-REF #c T-REF 'pres' & #c EVAL #d ==>
#c T-REF' #e & #e GLUE lam(T,lam(T2,drs([],[rel(overlap,T,T2)]))) : (#c_s -o (#d_s -o #c_t)).

//Non-future
#a s:: #b TEMP-REF #c T-REF 'non-future' & #c EVAL #d ==>
#c T-REF' #e & #e GLUE lam(T,lam(T2,drs([],[rel(nonfut,T,T2)]))) : (#c_s -o (#d_s -o #c_t)).


//Non-past
#a s:: #b TEMP-REF #c T-REF 'non-past' & #c EVAL #d ==>
#c T-REF' #e & #e GLUE lam(T,lam(T2,drs([],[rel(nonpast,T,T2)]))) : (#c_s -o (#d_s -o #c_t)).

//Future reference
#a s:: #b TEMP-REF #c T-REF 'future' & #c EVAL #d ==>
#c T-REF' #e & #e GLUE lam(T,lam(T2,drs([],[rel(after,T,T2)]))) : (#c_s -o (#d_s -o #c_t)).


//absolute tense closure -- fixed
#a s:: #b TEMP-REF #c T-REF %a & %a != 'undefined' & #c EVAL #d
==> #c GLUE lam(T,lam(P,lam(S,merge(drs([R],[]),merge(app(app(T,R),S),app(P,R)))))) : ((#c_s -o (#d_s -o #c_t)) -o ((#c_s -o #c_t) -o (#d_s -o #d_t))).

//aspectual tense closure
#a s:: #b ASP-TENSE #c A-REF %a &
#b TEMP-REF #e &
 %a != 'undefined'
==> #c GLUE lam(T,lam(P,lam(S,merge(drs([R],[]),merge(app(app(T,R),S),app(P,R)))))) : ((#c_s -o (#e_s -o #c_t)) -o ((#e_s -o #b_t) -o (#e_s -o #b_t))).

//unspec absolute closure
#a s:: #b TEMP-REF #c T-REF %a & %a == 'undefined' & #c EVAL #d
==> #c GLUE lam(P,lam(S,merge(app(P,S),drs([],[])))) : ((#c_s -o #b_t) -o (#d_s -o #b_t)).



//#a s:: #b TEMP-REF #c T-REF 'pres' & #c EVAL #d ==> #c GLUE [/P_<s,t>.[/s_s.Er_s[equals(r,s) \& P(r)]]] : ((#c -o #b) -o (#d -o #b)).

// #a s:: #b ASP-TENSE #c A-REF 'past' & #b TEMP-REF #d ==>  #c GLUE [/P_<s,t>.[/s_s.Er_s[before(r,s) \& P(r)]]] : ((#d -o #b) -o (#d -o #b)).

//#a s:: #b ASP-TENSE #c A-REF 'undefined' & #b TEMP-REF #d ==>  #c GLUE [/P_<s,t>.[/s_s.P(s)]] : ((#d -o #b) -o (#d -o #b)).
#a s:: #b ASP-TENSE #c A-REF 'undefined' & #b TEMP-REF #d ==>  #c GLUE lam(P,lam(S,merge(app(P,S),drs([],[])))) : ((#d_s -o #b_t) -o (#d_s -o #b_t)).
