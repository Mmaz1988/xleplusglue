DETPRON ENGLISH LEXICON (1.0)


"pronouns (not complete)"

I 	  PRON * @(PRON I 1 sg pers)
		 @(CASE nom).

You	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

you	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

He 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

he 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

She 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

she 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

it	  PRON * @(PRON it 3 sg pers).

We 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

we 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

They 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom).

they 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom).

My 	  PRON * @(POSS-PRON I sg 1).   "'I' or 'my' ??"

my 	  PRON * @(POSS-PRON I sg 1).

his 	  PRON * @(POSS-PRON he sg 3).

Her 	  PRON * {@(PRON she sg 3 pers)
		    |@(POSS-PRON she sg 3)}.

her 	  PRON * @(PRON her 3 sg pers).

Him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).

him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).

Their   PRON * @(POSS-PRON they 3 pl).

their   PRON * @(POSS-PRON they 3 pl).



"expletive"
There PRON *   (^PRON-TYPE) = expl_
	             (^PRON-FORM) = it
	             @(QUANT-SCOPE ^ %q)
	             :$ lam(Q,merge(drs([X],[]),app(Q,X))) :
                  ((s::^_e -o %q_t) -o %q_t) || noscope.

	             "(^PERS) = 3 (^NUM) = sg"  "standard analysis, but some"
	             "{(^NUM) =sg |(^NUM) = pl}"
	             "(^NUM)"
	             "inherit features from subject??"

"relative who -- semantics are stored in the lexical entry because [] are not allowed in semantic c-structure annotations
This requires a number of IOFA to work"

who PRON *      (^PRON-TYPE) = rel
                (^PRON-FORM) = who
                (^PRED) = 'PRO'
                {(^NUM) =sg |(^NUM) = pl}
                s::(ADJUNCT TOPIC ^) = %sem
                    (TOPIC ^) = %rel
                    (s::%rel SIT) = %sit
                    (%rel {SUBJ | OBJ}) = %arg
                :$ lam(P,lam(Q,lam(X,merge(app(P,X),app(Q,X))))) :
                   ((%sem_e -o %sem_t) -o ((s::%arg_e -o %sit_t) -o (%sem_e -o %sem_t))) || noscope.


"determiners"

the 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +        "encoded as det-type in inness"
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)) || noscope.

The 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)) || noscope.


a 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


an 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

A 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

An 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

more 	  DComp * (^PRED)='more<(^ OBL-COMP)>'
		        (^NUM) = pl
		        (^DEGREE) = comparative; "marks the NP as comparative to allow CPComps to apply"
		  D * @(SPEC-AQUANT-PRED many)
              (^ DEF) = -
          	  (^ NUM) = pl
           	  @(QUANT-SCOPE ^ %q).

More 	  DComp * (^DEF) = - "this indefinite only marks plurals"
                @(SPEC-QUANT-TYPE comparative)
		        (^NUM) = pl
		        (^DEGREE) = comparative. "marks the NP as comparative to allow CPComps to apply"

many     DComp * @(PRED many)
         		 (^NUM) = pl
         		 (^DEGREE) ~= comparative
         		 (^DEGREE) ~= superlative; "marks the NP as comparative to allow CPComps to apply"
         D * @(SPEC-AQUANT-PRED many)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).

Many     DComp * (^ PRED)='many<>(^ OBL-COMP)'
                 (^DEF) = - "this indefinite only marks plurals"
         		 (^NUM) = pl
         		 (^DEGREE) ~= comparative
         		 (^DEGREE) ~= superlative; "marks the NP as comparative to allow CPComps to apply"
         D * @(SPEC-AQUANT-PRED many)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).


"changed to spec-quant"
every 	  D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

Every 	   D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


"new quantifiers"

"semantics for some is copied from a/an"
some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      "(^ NUM) = pl" "some man and some men both work :)"
 	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

Some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      "(^ NUM) = pl"
 	        @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

"preliminary semantics for all, copied from every"
"also for Fracas Testsuite"
"EX: All mice are animals"
all 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

All 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


"each: semantics from all"
Each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q)
 	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q)
 	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


No D * @(SPEC-QUANT-PRED no)
       @(SPEC-QUANT-TYPE negative)
       (^ DEF) = -
       @(QUANT-SCOPE ^ %q)
       :$ lam(P,lam(Q,drs([],[not(merge(drs([X],[]),merge(app(P,X),app(Q,X))))]))) :
              	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

no D * @(SPEC-QUANT-PRED no)
       @(SPEC-QUANT-TYPE negative)
       (^ DEF) = -
       @(QUANT-SCOPE ^ %q)
       :$ lam(P,lam(Q,drs([],[not(merge(drs([X],[]),merge(app(P,X),app(Q,X))))]))) :
       	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

Both D *  @(SPEC-QUANT-PRED both)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

both D *  @(SPEC-QUANT-PRED both)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

Neither  D * @(SPEC-QUANT-PRED neither)
         @(SPEC-QUANT-TYPE negative)
          (^ DEF) = -
          (^ NUM) = sg
          @(QUANT-SCOPE ^ %q).

neither  D * @(SPEC-QUANT-PRED neither)
         @(SPEC-QUANT-TYPE negative)
          (^ DEF) = -
          (^ NUM) = sg
          @(QUANT-SCOPE ^ %q).


"AQUANTS"

Several D * @(SPEC-AQUANT-PRED several)
             "no quant type?"
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).


several D * @(SPEC-AQUANT-PRED several)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).


Most    D* @(SPEC-AQUANT-PRED most)
            @(SPEC-AQUANT-TYPE superlative)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).

most    D* @(SPEC-AQUANT-PRED most)
            @(SPEC-AQUANT-TYPE superlative)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).


Few D *      @(SPEC-AQUANT-PRED few)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).

few D *      @(SPEC-AQUANT-PRED few)
             (^ DEF) = -
	         (^ NUM) = pl
 	        @(QUANT-SCOPE ^ %q).

"partitives"

"A few of the men appeared"
"At least a few of the men appeared"

"At least - literature"


A` few    D * {@(SPEC-QUANT-PRED a` few)
	            (^ DEF) = -
	            (^ NUM) = pl
	            @(QUANT-SCOPE ^ %q)
	            :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
                	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)),
 	            |
 	            @(PARTITIVE a` few)}.

a` few    D * {@(SPEC-QUANT-PRED a` few)
	            (^ DEF) = -
	            (^ NUM) = pl
 	            "@(QUANT-SCOPE ^ %q)"
 	            |
 	            @(PARTITIVE a` few)}.


At` least  ADV * (^PRED) = 'at` least'
                 (^ADV-TYPE) = num.

at` least  ADV * (^PRED) = 'at` least'
                 (^ADV-TYPE) = num.

At` most  ADV * (^PRED) = 'at` most'
                 (^ADV-TYPE) = num.

at` most  ADV * (^PRED) = 'at` most'
                 (^ADV-TYPE) = num.

Exactly   ADV * (^PRED) = 'exactly'
                 (^ADV-TYPE) = num.

exactly   ADV * (^PRED) = 'exactly'
                 (^ADV-TYPE) = num.

twice   ADV * (^PRED) = 'twice'
               (^ADV-TYPE) = num.

"numbers/measure words/numerals"
One     NUMBER *  { @(NUMBER-PL 1 sg)
                   | @(NUMBER-PART 1)}
                    "{@(SPEC-NUMBER-PRED one)
                   (^ DEF) = -
	               (^ NUM) = sg
	               |
	               @(PARTITIVE one)
	               (^NUMBER-TYPE) = cardinal}".

one     NUMBER *  { @(NUMBER-PL 1 sg)
                   | @(NUMBER-PART 1)}.

1      NUMBER *  { @(NUMBER-PL 1 sg)
                   | @(NUMBER-PART 1)}.

"two     NUMBER *  {@(SPEC-NUMBER-PRED two)
                   (^ DEF) = -
	               (^ NUM) = pl
	               |
	               @(PARTITIVE two)
	               (^NUMBER-TYPE) = cardinal}."

"three     NUMBER *  {@(SPEC-NUMBER-PRED three)
                   (^ DEF) = -
	               (^ NUM) = pl
	               |
	               @(PARTITIVE three)
	               (^NUMBER-TYPE) = cardinal}."




"Mary sold One more computer than John."

"EX: ITEL sold 3000 more computers than APCOM."
"EX: ITEL is faster than 500 MIPS."

"ten 	  NUMBER *  @(SPEC-NUMBER-PRED ten)
                    (^ DEF) = -
	                (^ NUM) = pl.

500	      NUMBER *  @(SPEC-NUMBER-PRED 500)
                   (^ DEF) = -
	               (^ NUM) = pl.

3000      NUMBER * @(SPEC-NUMBER-PRED 3000).

2500      NUMBER *  @(SPEC-NUMBER-PRED 2500)
                   (^ DEF) = -
	               (^ NUM) = pl."


"very preliminary any"
any D * @(SPEC-QUANT-PRED some)
        (^ DEF) = -
        @(QUANT-SCOPE ^ %q).

----