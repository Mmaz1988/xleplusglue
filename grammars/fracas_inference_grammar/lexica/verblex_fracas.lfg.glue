VERB ENGLISH LEXICON (1.0)


"all verbs here -- still need to convert fully to just have lemmas"

"verbs with clausal arguments"

say 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
                    @(EVENT %stem)
                    @(ARG1 (^SUBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

"ToDo implement passives for complement verbs (i.e., distinguish between OBJ vs COMP)"

think 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
	      %s = s::(^ COMP)
	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
          (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

"
ensure    V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(ensure,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).
"

"
convince can be both COMP or XCOMP
"

convince  V-S XLE {(^PRED) = '%stem<(^SUBJ)(^OBJ)(^COMP)>'
          @(EVENT %stem)
                    @(ARG1 (^SUBJ))
                    @(ARG2 (^OBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,P) : (%s_t -o (%s SIT)_t),
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))),
            |
          (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  @(ARG2 (^OBJ))
		  (^ XCOMP SUBJ) = (^OBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.


try 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))).

seem 	  V-S XLE (^PRED) = '%stem<(^SUBJ)>(^XCOMP)'
          @(EVENT %stem)
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
		  (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

want 	  V-S XLE { (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  |
		  (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
          @(ARG2 (^OBJ))
          (^ XCOMP SUBJ) = (^OBJ)
          %s = s::(^ XCOMP)
          :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
          ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.



get V-S XLE {@(DITRANS-EV %stem) |
          (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'     "OBJ"
          @(EVENT %stem)
		  }.

"Intransitives"

appear 	  V-S XLE @(INTRANS-EV %stem).

disappear V-S XLE @(INTRANS-EV %stem).

laugh 	  V-S XLE @(INTRANS-EV %stem).

meow       V-S XLE @(INTRANS-EV %stem).

sleep 	  V-S XLE @(INTRANS-EV %stem).

live       V-S XLE @(INTRANS-EV %stem).

wait 	  V-S XLE { @(INTRANS-EV wait) |
		@(INTRANS-OBL wait)
		"this is the non-semantic OBL wait on a customer use"
		(^ OBL PFORM) =c on
		(^ PSEM) =c nosem }.


"Optional transitives"

travel    V-S XLE @(OPT-TRANS-EV %stem).

sing      V-S XLE @(OPT-TRANS-EV %stem).

drinks 	  V-S XLE @(OPT-TRANS-EV %stem).

eat 	  V-S XLE @(OPT-TRANS-EV %stem).

escape 	  V-S XLE @(OPT-TRANS-EV %stem).

win       V-S XLE @(OPT-TRANS-EV %stem).

lose      V-S XLE @(OPT-TRANS-EV %stem).

sell      V-S XLE @(OPT-TRANS-EV %stem).

do        V-S XLE @(OPT-TRANS-EV %stem).

"Transitives"

like      V-S XLE @(TRANS-EV %stem).

become 	  V-S XLE @(TRANS-EV %stem).

devour 	  V-S XLE @(TRANS-EV %stem).

lick 	  V-S XLE @(TRANS-EV %stem).

hate 	  V-S XLE @(TRANS-EV %stem).  "using the morphological analyzer"

hug V-S XLE @(TRANS-EV %stem);ETC.

implement V-S XLE @(TRANS-EV %stem).

love 	  V-S XLE @(TRANS-EV %stem).

receive   V-S XLE @(TRANS-EV %stem).

see 	  V-S XLE @(TRANS-EV %stem).

have      V-S XLE @(TRANS-EV %stem).

obtain    V-S XLE @(TRANS-EV %stem).

finish   V-S XLE @(TRANS-EV %stem).

publish  V-S XLE @(TRANS-EV %stem).

spend    V-S XLE @(TRANS-EV %stem).

"take 	V-S XLE @(TRANS-EV %stem)."

"take` part V-S XLE @(INTRANS-EV %stem)."

takes` part V[fin] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                @(PROG -_)
                @(PERF -_)
                @S-AGR
                @(VPRES)
                (^VFORM) = fin.

take` part V[base] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                      @(PROG -_)
                      @(PERF -_)
                      (^VFORM) = inf;
           V[fin] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                        @(PROG -_)
                        @(PERF -_)
                        (^TNS-ASP TENSE) = pres
                        (^VFORM) = fin.



"use: either 'to use smth' or 'used to xyz'"

use     V-S XLE { @(TRANS-EV %stem) |
                    (^PRED) = '%stem<(^XCOMP)>(^SUBJ)'
                    (^ XCOMP SUBJ) = (^SUBJ)
                    (^TNS-ASP TENSE) =c past}.

"Ditransitives"

give 	  V-S XLE @(DITRANS-EV give).

contribute V-S XLE @(DITRANS-EV contribute).


"comes: eg. 'comes cheap'"


come V-S XLE    (^PRED) = 'come<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
               "(^ PREDLINK PRED) c= 'cheap'".

"to be"

"MOOD, PERF, PROG, PAST - theres templates for this"

"present: am(1sg), are(pl, 2sg, all person), is(3sg)  + aux is"

is   AUX[fin] *   @VPRESBE       "template without inf option"
		          @(PROG -_)
		          @(PERF -_)
		          @S-AGR       "3sg"
		          { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                                 @(EVENT be)
                                 @(ARG1 (^ SUBJ))
                                 @(ARG2 (^ PREDLINK)) "EX. Every man is a tenor, There was an Italian"
                                |
                                 (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                                 (^SUBJ) = (^ PREDLINK SUBJ)
                                 @(EVENT be)
                                 @(ARG1 (^ SUBJ)) "the dog was fast"
                                 }.

     "
      AUX * @(TENSE pres)
		    { (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg.
                "

am   V *   @VPRESBE
		   @(PROG -_)
		   @(PERF -_)
		   (^SUBJ PERS) = 1
	       (^SUBJ NUM) = sg
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               "(^SUBJ) = (^ PREDLINK SUBJ)"
               @(EVENT %stem)}.

are  AUX[fin] *   @VPRESBE
		   @(PROG -_)
		   @(PERF -_)
		   {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                          @(EVENT be)
                          @(ARG1 (^ SUBJ))
                          @(ARG2 (^ PREDLINK)) "EX. Every man is a tenor, There was an Italian"
                         |
                          (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                          (^SUBJ) = (^ PREDLINK SUBJ)
                          @(EVENT be)
                          @(ARG1 (^ SUBJ)) "the dog was fast"
                          }.


"past: was(1sg, 3sg), were(pl, 2sg)  + aux was"

was   AUX[fin] *  @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {@S-AGR @(OT-MARK Be-3pl)
		   |
		   (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT be)
               @(ARG1 (^ SUBJ))
               @(ARG2 (^ PREDLINK)) "EX. Every man is a tenor, There was an Italian"
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT be)
               @(ARG1 (^ SUBJ)) "the dog was fast"
               };
       AUX[pass,fin] * @VPAST
       		           @S-AGR
       		           (^VFORM) = fin
       		           (^PASSIVE) = +.


        "AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
            { (^ SUBJ PERS) = 1
               | (^ SUBJ PERS) = 3
            }
            (^ SUBJ NUM) = sg."


were[fin]   V *  @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)};
       AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
            (^ SUBJ NUM) = pl.

"future"

will    AUX[fin] * @VFUT "@(TENSE past)"
              "@(PROG -_)
              @(PERF -_)"
              (^ SUBJ NUM)
              (^ SUBJ PERS)
              (^ FIN) = +
              (^ VTYPE) = fin
              @(EVENT %stem). "semantics don't work here"


"be, (being, been??)"

be   AUX[base] *  (^VFORM) = inf
		   @(PROG -_)
		   @(PERF -_)
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                          @(EVENT be)
                          @(ARG1 (^ SUBJ))
                          @(ARG2 (^ PREDLINK)) "EX. Every man is a tenor"
                         |
                          (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
                          (^SUBJ) = (^ PREDLINK SUBJ)
                          @(EVENT be)
                          { @(ARG1 (^ PREDLINK)) | @(ARG1 (^ SUBJ))} "EX. There was an Italian vs. the dog was fast"
                          }.

"auxiliaries"


can    AUX[fin] *  (^PRED) = 'can<(^SUBJ)(^XCOMP)>'
             (^ XCOMP SUBJ) = (^SUBJ)
              (^ VFORM) = modal
              @VPRES.


did AUX[fin] * @VPAST.


"did       V-S XLE @(INTRANS-EV %stem)."

----