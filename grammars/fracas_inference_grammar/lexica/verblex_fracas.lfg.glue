VERB ENGLISH LEXICON (1.0)


"all verbs here -- still need to convert fully to just have lemmas"

"verbs with clausal arguments"

say 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
                    @(EVENT %stem)
                    @(ARG1 (^SUBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

"ToDo implement passives for complement verbs (i.e., distinguish between OBJ vs COMP)"

think 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
	      %s = s::(^ COMP)
	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
          (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).


know	  V-S XLE  {
                    (^PRED) = '%stem<(^SUBJ)(^COMP)>'
                    @(EVENT %stem)
                    @(ARG1 (^SUBJ))
                    %s = s::(^ COMP)
                    :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t)))
                    |
                    @(TRANS-EV %stem)
                   }.



"
ensure    V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(ensure,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).
"

"
convince can be both COMP or XCOMP
"

convince  V-S XLE {(^PRED) = '%stem<(^SUBJ)(^OBJ)(^COMP)>'
          @(EVENT %stem)
                    @(ARG1 (^SUBJ))
                    @(ARG2 (^OBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,P) : (%s_t -o (%s SIT)_t),
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))),
            |
          (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  @(ARG2 (^OBJ))
		  (^ XCOMP SUBJ) = (^OBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.


try 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))).

seem 	  V-S XLE (^PRED) = '%stem<(^SUBJ)>(^XCOMP)'
          @(EVENT %stem)
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
		  (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

want 	  V-S XLE { (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  |
		  (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
          @(ARG2 (^OBJ))
          (^ XCOMP SUBJ) = (^OBJ)
          %s = s::(^ XCOMP)
          :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
          ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.



get V-S XLE {@(DITRANS-EV %stem) |
          (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'     "OBJ"
          @(EVENT %stem)
		  }.

"Intransitives"

appear 	  V-S XLE @(INTRANS-EV %stem).

disappear V-S XLE @(INTRANS-EV %stem).

laugh 	  V-S XLE @(INTRANS-EV %stem).

meow       V-S XLE @(INTRANS-EV %stem).

sleep 	  V-S XLE @(INTRANS-EV %stem).

live       V-S XLE @(INTRANS-EV %stem).

wait 	  V-S XLE { @(INTRANS-EV wait) |
		@(INTRANS-OBL wait)
		"this is the non-semantic OBL wait on a customer use"
		(^ OBL PFORM) =c on
		(^ PSEM) =c nosem }.


"Optional transitives"

smoke   V-S XLE @(OPT-TRANS-EV %stem).

snort    V-S XLE @(OPT-TRANS-EV %stem).

travel    V-S XLE @(OPT-TRANS-EV %stem).

sing      V-S XLE @(OPT-TRANS-EV %stem).

drinks 	  V-S XLE @(OPT-TRANS-EV %stem).

eat 	  V-S XLE @(OPT-TRANS-EV %stem).

escape 	  V-S XLE @(OPT-TRANS-EV %stem).

win       V-S XLE @(OPT-TRANS-EV %stem).

lose      V-S XLE @(OPT-TRANS-EV %stem).

sell      V-S XLE @(OPT-TRANS-EV %stem).

do        V-S XLE @(OPT-TRANS-EV %stem).

"Transitives"

like      V-S XLE @(TRANS-EV %stem).

become 	  V-S XLE @(TRANS-EV %stem).

devour 	  V-S XLE @(TRANS-EV %stem).

lick 	  V-S XLE @(TRANS-EV %stem).

hate 	  V-S XLE @(TRANS-EV %stem).  "using the morphological analyzer"

hug V-S XLE @(TRANS-EV %stem);ETC.

implement V-S XLE @(TRANS-EV %stem).

love 	  V-S XLE @(TRANS-EV %stem).

receive   V-S XLE @(TRANS-EV %stem).

see 	  V-S XLE @(TRANS-EV %stem).

have      V-S XLE @(TRANS-EV %stem).

obtain    V-S XLE @(TRANS-EV %stem).

finish   V-S XLE @(TRANS-EV %stem).

publish  V-S XLE @(TRANS-EV %stem).

spend    V-S XLE @(TRANS-EV %stem).

"take 	V-S XLE @(TRANS-EV %stem)."

"take` part V-S XLE @(INTRANS-EV %stem)."

takes` part V[fin] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                @(PROG -_)
                @(PERF -_)
                @S-AGR
                @(VPRES)
                (^VFORM) = fin.

take` part V[base] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                      @(PROG -_)
                      @(PERF -_)
                      (^VFORM) = inf;
           V[fin] * {@(INTRANS-EV %stem) | @(INTRANS-OBL-EV %stem) }
                        @(PROG -_)
                        @(PERF -_)
                        (^TNS-ASP TENSE) = pres
                        (^VFORM) = fin.



"use: either 'to use smth' or 'used to xyz'"

use     V-S XLE { @(TRANS-EV %stem) |
                    (^PRED) = '%stem<(^XCOMP)>(^SUBJ)'
                    (^ XCOMP SUBJ) = (^SUBJ)
                    (^TNS-ASP TENSE) =c past}.

"Ditransitives"

give 	  V-S XLE @(DITRANS-EV give).

contribute V-S XLE @(DITRANS-EV contribute).


"comes: eg. 'comes cheap'"


come V-S XLE    (^PRED) = 'come<(^PREDLINK)>(^SUBJ)'
                           (^SUBJ) = (^ PREDLINK SUBJ)
                           "@AUX-RAISE"
                           @(EVENT come)
                           @(ARG1 (^ SUBJ)).

"to be"

"MOOD, PERF, PROG, PAST - theres templates for this"

"present: am(1sg), are(pl, 2sg, all person), is(3sg)  + aux is"

is   AUX[fin] *   @BE-TRANS-EV
                  @VPRESBE       "template without inf option"
		          @(PROG -_)
		          @(PERF -_)
		          @S-AGR       "3sg"
		          .

     "AUX * @(TENSE pres)
		    { (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg."

am   AUX[fin] *  @BE-TRANS-EV
                @VPRESBE
               @(PROG -_)
               @(PERF -_)
               (^SUBJ PERS) = 1
               (^SUBJ NUM) = sg.


are  AUX[fin] *   @BE-TRANS-EV
                  @VPRESBE
                  @(PROG -_)
                  @(PERF -_)
                  {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
                   (^ SUBJ PERS) = 2
	               (^ SUBJ NUM) = sg}.


"past: was(1sg, 3sg), were(pl, 2sg)  + aux was"

was   AUX[fin] *  @BE-TRANS-EV
           @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {@S-AGR @(OT-MARK Be-3pl)
		   |
		   (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg};
       AUX[pass,fin] * @VPAST
       		           @S-AGR
       		           (^VFORM) = fin
       		           (^PASSIVE) = +.


        "AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
            { (^ SUBJ PERS) = 1
               | (^ SUBJ PERS) = 3
            }
            (^ SUBJ NUM) = sg."


were  Aux[fin]  *  @BE-TRANS-EV
            @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg};
       AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
            (^ SUBJ NUM) = pl.

"future"

will    AUX[fut,fin] * @VFUT "@(TENSE past)"
              "@(PROG -_)
              @(PERF -_)"
              (^ SUBJ NUM)
              (^ SUBJ PERS)
              (^ FIN) = +
              (^ VTYPE) = fin. "semantics don't work here"


"be, (being, been??)"

be   AUX[base] *  (^VFORM) = inf
                   @(PROG -_)
                   @(PERF -_)
                   @BE-TRANS-EV
             "|
              ^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
              (^SUBJ) = (^ PREDLINK SUBJ)
              @(EVENT be)
              { @(ARG1 (^ PREDLINK)) | @(ARG1 (^ SUBJ))}" "EX. There was an Italian vs. the dog was fast"
              .

"auxiliaries"


can    AUX[fin] *  (^PRED) = 'can<(^SUBJ)(^XCOMP)>'
             (^ XCOMP SUBJ) = (^SUBJ)
              (^ VFORM) = modal
              @VPRES.


did AUX[fin] * @VPAST.


"did       V-S XLE @(INTRANS-EV %stem)."

----