VERB ENGLISH LEXICON (1.0)


"all verbs here -- still need to convert fully to just have lemmas"

"verbs with clausal arguments"

say 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
                    @(EVENT %stem)
                    @(ARG1 (^SUBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

"ToDo implement passives for complement verbs (i.e., distinguish between OBJ vs COMP)"

think 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
	      %s = s::(^ COMP)
	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
          (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

"
ensure    V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(ensure,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).
"

"
convince can be both COMP or XCOMP
"

convince  V-S XLE {(^PRED) = '%stem<(^SUBJ)(^OBJ)(^COMP)>'
          @(EVENT %stem)
                    @(ARG1 (^SUBJ))
                    @(ARG2 (^OBJ))
          	      %s = s::(^ COMP)
          	      :$ lam(P,P) : (%s_t -o (%s SIT)_t),
          	      :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
                    (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))),
            |
          (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  @(ARG2 (^OBJ))
		  (^ XCOMP SUBJ) = (^OBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.


try 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))).

seem 	  V-S XLE (^PRED) = '%stem<(^SUBJ)>(^XCOMP)'
          @(EVENT %stem)
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(P,lam(S,lam(V,merge(app(P,V),drs([],[cont(V,S)]))))) :
		  (((s::^ EV)_v -o (s::^ EV)_t) -o ((%s SIT)_t -o ((s::^ EV)_v -o (s::^ EV)_t))).

want 	  V-S XLE { (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @(EVENT %stem)
		  @(ARG1 (^SUBJ))
		  (^ XCOMP SUBJ) = (^SUBJ)
		  %s = s::(^ XCOMP)
		  :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
		  ((s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^SUBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  |
		  (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
          @(EVENT %stem)
          @(ARG1 (^SUBJ))
          @(ARG2 (^OBJ))
          (^ XCOMP SUBJ) = (^OBJ)
          %s = s::(^ XCOMP)
          :$ lam(V,lam(P,lam(X,lam(E,merge(app(app(V,X),E),drs([],[cont(E,app(P,X))])))))) :
          ((s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)) -o ((s::(^ XCOMP SUBJ)_e -o (%s SIT)_t) -o (s::(^OBJ)_e -o ((s::^ EV)_v -o (s::^ EV)_t)))),
		  }.

"
For future reference to implement active and passive forms for xcomp verbs
believe V-S XLE @(PASS (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>')
          @(XCOMP-OBJ-PASSIVE-ARGS %arg1 %arg2 %arg3)
		  @ATTITUDE
		  (^ XCOMP SUBJ) = %arg2
		  :$ lam(X, lam(Y,lam(P,lam(S,drs([],[pred(believe,S), rel(arg1,X,S), rel(arg2,Y,S), cont(S,app(app(P,Y),S))]))))) :
          (s::%arg1_e -o (s::%arg2_e -o ((s::(^XCOMP SUBJ)_e -o ((s::(^ XCOMP) SIT) _s -o (s::(^ XCOMP) SIT)_t)) -o ((s::^ SIT)_s -o (s::^ SIT)_t)))).
"


"Intransitives"

did       V-S XLE @(INTRANS-EV %stem).

appear 	  V-S XLE @(INTRANS-EV %stem).

disappear V-S XLE @(INTRANS-EV %stem).

laugh 	  V-S XLE @(INTRANS-EV %stem).

meow       V-S XLE @(INTRANS-EV %stem).

sleep 	  V-S XLE @(INTRANS-EV %stem).

live       V-S XLE @(INTRANS-EV %stem).

wait 	  V-S XLE { @(INTRANS-EV wait) |
		@(INTRANS-OBL wait)
		"this is the non-semantic OBL wait on a customer use"
		(^ OBL PFORM) =c on
		(^ PSEM) =c nosem }.

"Optional transitives"

travel    V-S XLE @(OPT-TRANS-EV %stem).

sing      V-S XLE @(OPT-TRANS-EV %stem).

drinks 	  V-S XLE @(OPT-TRANS-EV %stem).

eat 	  V-S XLE @(OPT-TRANS-EV %stem).

escape 	  V-S XLE @(OPT-TRANS-EV %stem).

win       V-S XLE @(OPT-TRANS-EV %stem).

lose      V-S XLE @(OPT-TRANS-EV %stem).

sell      V-S XLE @(OPT-TRANS-EV %stem).

do        V-S XLE @(OPT-TRANS-EV %stem).

"Transitives"

like      V-S XLE @(TRANS-EV %stem).

become 	  V-S XLE @(TRANS-EV %stem).

devour 	  V-S XLE @(TRANS-EV %stem).

lick 	  V-S XLE @(TRANS-EV %stem).

hate 	  V-S XLE @(TRANS-EV %stem).  "using the morphological analyzer"

hug V-S XLE @(TRANS-EV %stem);ETC.

implement V-S XLE @(TRANS-EV %stem).

love 	  V-S XLE @(TRANS-EV %stem).

receive   V-S XLE @(TRANS-EV %stem).

see 	  V-S XLE @(TRANS-EV %stem).

have      V-S XLE @(TRANS-EV %stem).

"Ditransitives"

give 	  V-S XLE @(DITRANS-EV give).

contribute V-S XLE @(DITRANS-EV contribute).


"comes: eg. 'comes cheap'"


come V-S XLE    (^PRED) = 'come<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
               "(^ PREDLINK PRED) c= 'cheap'".

"to be"

"MOOD, PERF, PROG, PAST - theres templates for this"

"present: am(1sg), are(pl, 2sg, all person), is(3sg)  + aux is"

is   V *   @VPRESBE       "template without inf option"
		   @(PROG -_)
		   @(PERF -_)
		   @S-AGR       "3sg"
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               "@(EVENT %stem)"
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               "@(EVENT %stem)"
               };
      AUX * @(TENSE pres)
		    { (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg.

am   V *   @VPRESBE
		   @(PROG -_)
		   @(PERF -_)
		   (^SUBJ PERS) = 1
	       (^SUBJ NUM) = sg
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               "(^SUBJ) = (^ PREDLINK SUBJ)"
               @(EVENT %stem)}.

are  V *   @VPRESBE
		   @(PROG -_)
		   @(PERF -_)
		   {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)}.


"past: was(1sg, 3sg), were(pl, 2sg)  + aux was"

was   V *  @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {@S-AGR @(OT-MARK Be-3pl)
		   |
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)};
        AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
            { (^ SUBJ PERS) = 1
               | (^ SUBJ PERS) = 3
            }
            (^ SUBJ NUM) = sg.


were   V *  @VPAST
		   @(PROG -_)
		   @(PERF -_)
		   {(^ SUBJ NUM) = pl @(OT-MARK Be-3pl)|
		     (^ SUBJ PERS) = 2
	       (^ SUBJ NUM) = sg}
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)}.

"future"

will    AUX * @VFUT "@(TENSE past)"
              "@(PROG -_)
              @(PERF -_)"
              (^ SUBJ NUM)
              (^ SUBJ PERS)
              (^ FIN) = +
              @(EVENT %stem). "semantics don't work here"


"be, (being, been??)"

be   V *  (^VFORM) = inf
		   @(PROG -_)
		   @(PERF -_)
		   { (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               @(EVENT %stem)
              |
               (^PRED) = 'be<(^PREDLINK)>(^SUBJ)'
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)}.

"auxiliaries"


can    AUX * @VPRES
              "@(PROG -_)
              @(PERF -_)"
              (^ SUBJ NUM)
              (^ SUBJ PERS)
              (^ FIN) = +
             @(EVENT %stem). "  semantics don't work here"


did AUX * @VPAST.

----