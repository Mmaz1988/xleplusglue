GLUE   BASIC   TEMPLATES (1.0)

   LLIMP(N L R) = (N ANT) = L
	  (N CONS) = R.

   LLATOM(N L T) = (N RESOURCE) = L
	  (N TYPE) = T.

   LLCLOSURE(G) = G $ (g::* GLUE).

   GLUE-MEANING(R M) =
	  (R MEANING) = M.

  NOSCOPE(G) = (G NOSCOPE) = +.

   NAME-SCOPE(UP NAME) =
   %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | OBL-COMP | ADJUNCT | PREDLINK | OBL-PART | $}+ ^)
   (%name FIN) =c +
   NAME  = s::%name
   (s::^ QUANT-SCOPE) = NAME.

     QUANT-SCOPE(UP NAME) =
  	  %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL-COMP | OBL | ADJUNCT | PREDLINK | OBL-PART | $}+ ^) "PREDLINK added so determiners are compatible eg. 'Mary is a dog'"
  	  (s::%name EV TYPE) =c eventuality
  	  NAME = s::%name
      (s::^ QUANT-SCOPE) = NAME.
" Why does the below not work?
   QUANT-SCOPE(UP NAME) =
	  NAME = s::({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT | PREDLINK}+ ^)
	  (NAME EV TYPE) =c eventuality
	  (s::^ QUANT-SCOPE) = (NAME SIT).
	  "

"
   ATTITUDE = (s::^ SIT) = %s
   	      (s::^ EV TYPE) = eventuality.
"

"In principle, the identity function is not necessary but it makes interaction with LiGER simpler"

   EVENT(REL) =
	  (s::^ EV TYPE) = eventuality
	  (s::^ SIT) = %sit
	  :$ lam(P,P) : (s::^_t -o %sit_t),
	  :$ lam(V,drs([],[pred(REL,V)])) : ((s::^ EV)_v -o (s::^ EV)_t),
	  :$ lam(V,merge(drs([E],[]),app(V,E))) : (((s::^ EV)_v -o (s::^ EV)_t) -o s::^_t).

   PREP-SEM(P) =
             {
	     %scope = (s::({ADJUNCT | PREDLINK} ^) EV)
	     (%scope TYPE) =c eventuality
	    :$ lam(U,lam(V,lam(E,merge(drs([],[]),merge(app(U,E),app(V,E)))))) :
	    ((%scope_v -o s::^_t) -o ((%scope_v -o %scope_t) -o (%scope_v -o %scope_t))),
	    :$ lam(Y,lam(X,drs([],[rel(P,X,Y)]))) : (s::(^OBJ)_e -o (%scope_v -o s::^_t)),
	    |
	    %scope = s::(ADJUNCT ^)
	    (%scope TYPE) =c entity
	    :$ lam(U,lam(V,lam(E,merge(drs([],[]),merge(app(U,E),app(V,E)))))) :
	    ((s::(ADJUNCT ^)_e -o s::^_t) -o ((s::(ADJUNCT ^)_e -o %scope_t) -o (s::(ADJUNCT ^)_e -o %scope_t))) || noscope,
	    :$ lam(Y,lam(X,drs([],[rel(P,X,Y)]))) : (s::(^OBJ)_e -o (s::(ADJUNCT ^)_e -o s::^_t)),
	     }.

"
 TENSE-CLOSURE = %tense = (s::^ TEMP-REF EVAL)
 :$ lam(P,merge(drs([T],[eq(T,now)]),app(P,T))) : ((%tense_s -o %tense_t) -o s::^_t).
"

   "Templates for argument structure. Need to be separate to avoid trouble with local names"
   ARG1(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg1,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.

   ARG2(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg2,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.

   ARG3(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg3,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.


DEFAULT-NOUN-SEM(P) = {@(PRED P) | (^ PRED) = 'P<>(^SUBJ)'}
                      	      (s::^ TYPE) = entity
                      		  { @(COUNT-NOUN-SEM P)
                      		  |
                      		  @(PROPER-NOUN-SEM P)
                      		  }.


COUNT-NOUN-SEM(P) = (^ NTYPE) = count
                  :$ lam(X,drs([],[pred('P',X)])) : (s::^_e -o s::^_t).

PROPER-NOUN-SEM(P) = (^ NTYPE NSYN) = proper
                             @(NAME-SCOPE ^ %q)
                             :$ lam(X,drs([],[eq(X,'P')])) : (s::^_e -o s::^_t),
                             {
                             :$ lam(Q,lam(R,merge(drs([X],[]),merge(app(Q,X),app(R,X))))) :
                             ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)) || noscope,
                             |
                             (^ DEF)
                             }.

----
