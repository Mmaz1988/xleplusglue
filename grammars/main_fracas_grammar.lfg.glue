DEMO   ENGLISH   CONFIG (1.0)
  ROOTCAT   ROOT.  "changed to ROOT from S"
  FILES common.templates.lfg  morph_fracas.lfg templates_fracas.lfg.
  LEXENTRIES   (DEMO ENGLISH) (MORPH ENGLISH).
  TEMPLATES (DEMO ENGLISH) (GLUE BASIC) (STANDARD COMMON).  "added common ParGram templates"
  RULES   (DEMO ENGLISH) (MORPH ENGLISH).
  MORPHOLOGY (DEMO ENGLISH).
  GOVERNABLERELATIONS    SUBJ OBJ OBJ2 COMP XCOMP OBL OBL-?+ PREDLINK.
  SEMANTICFUNCTIONS    ADJUNCT  TOPIC FOCUS POSS STANDARD.
  NONDISTRIBUTIVES   NUM PERS COORD-FORM.
  EPSILON   e.
  OPTIMALITYORDER NOGOOD  PPadj +PPattach +PPpassiv +sg-imp.
  GENOPTIMALITYORDER GenBadPunct NOGOOD +Punct.

----

DEMO   ENGLISH   RULES (1.0)

   ROOT --> "can have other things here as well, imperatives, etc." 
 	  { S: (^ ROOT) = +;
 	    (PERIOD: @(OT-MARK Punct)) "prefer for generation"
 	  | Simp}. 

  Simp --> e: (^ SUBJ PRED) = 'pro'
	       (^ SUBJ PERS) = 2; 
 	  VP
 	  EXCL.  "obligatory exclamation mark"

   S --> NP: (^ SUBJ)=!
	     (! CASE)=nom;
 	 VP: (^ TNS-ASP TENSE) "require that sentences have tense"
 	     (^ FIN) = +
	     (s::^ TEMP-REF EVAL) = %eval. "Tense needs to be evaluated against sth."

	 
   VP --> (AUX) "auxiliary introduced for passive" 
 	  V: ^=!;
 	  ({NP: (^ OBJ)=! "direct object"
	       (! CASE)=acc |
	       NP: (^ PREDLINK) = ! "to be + ..."
	       "referential subject must match object in number "
	       "eg. Mary is a dog vs *Mary is the dogs"
	       @(IF (^SUBJ NUM) (^SUBJ NUM)=c(^PREDLINK NUM)) |
	       AP[predicative]: (^ PREDLINK) = !
	            })
 	  (NP: (^ OBJ2) = !)


	  "secondary object"
 	  PP*: { ! $ (^ ADJUNCT) "PPs can be all types of adjuncts"
		 (! PTYPE) =c sem "only semantic PPs here"
		 "@(OT-MARK PPadj)" "disprefer adjunct PPs" 
	       | (^ OBL) = ! "or a a general oblique"
	       };
 	  (PP: (^ OBL-TO) = ! "special obl for ditransitives"
	       "example of a constraining equation: require a value with =c"
	       (! PFORM) =c to )
 	  (PP: (^ OBL-AG) = ! "oblique agent of passive" 
	       "example of a constraining equation: require a value with =c" 
	       (! PFORM) =c by
	       @(OT-MARK PPpassiv))
 	  ({ CP: (^ COMP) = !
 	  	|
 		VPinf: (^XCOMP) = !
 		 (! FIN) = -
		 (! VFORM) = inf
 		 (s::^ TEMP-REF) = (s::(^XCOMP) EVAL)}
 		 )

    (ADVP: ! $ (^ ADJUNCT))

    "rule for phrasal comparative"
    "EX: He laughs greater than her."
    "somewhat preliminary, should not be 'predicative', works for the moment though"
    (AP[predicative]: ! $ (^ ADJUNCT)).

   ADVP --> VP: (^ SUBJ PRED) = 'pro'
   	    	~[(^ TNS-ASP TENSE)].

   CP -->  C
	   S. 


  "aber who sollte ja eigentlich zum gleichen subject wie der main clause referen"
  "get features of the NP on the who somehow -> NUM und PERS"
   CPrel --> NP: (! PRON-TYPE) =c rel
                 (^ SUBJ) = !
                 "(^NUM ADJUNCT SUBJ) = (!NUM)"
                 ;
              VP.


   VPinf --> PARTinf VP. 


   NP --> "either a full NP or a PRON"
 	  { ( {D: ^=! | PRON})
	    "optional determiner"
 	     AP[attributive]*: ! $ (^ ADJUNCT); "introducing adjectives in sets"

 	     N: ^=!;
	    "head of NP"

	    "comparison with whole NPs"
	    "EX: He is a fatter politician than him."
        (CPComp: (^ ADJUNCT $ OBL-COMP) = !)


	    (CPrel: ! $ (^ ADJUNCT))

 	    PP*: ! $ (^ ADJUNCT) "PPs modifying NPs" 
		(! PTYPE) =c sem "have to be semantic"
		 "@(OT-MARK PPattach)" "prefer PPs attached to NPs"
 	  | PRON}. 


   AP[_type $ {attributive predicative}] -->

        (ADVComp: _type = predicative
                  ! $ (^ ADJUNCT))

        ADV*: ! $ (^ ADJUNCT);

        A*: ^=!;

        "than-comparatives as adjuncts on the AP"
        "type of comparative is handled in the lexicon"
        "EX1: The tree is greater than the plant."
        "EX2: The tree is (as) great (as the plant)."
        (CPComp: _type = predicative
                 (^ OBL-COMP) = !)
        (COMMA).



   "rule for comparison constructions"
   "EX: He is greater than the dog (is)."
   CPComp --> CComp
 	      { NP: (^ OBJ) = !
		        (! CASE) = acc
 	      |
 	        "for elliptical constructions."
            "EX: He is greater than the dog is (great)."
 	        S: (^ OBJ) = !
 	      }.


   PP --> { P: ^ = ! "head of PP"
	       (! PTYPE) =c sem; "semantic type, Adjunct"
 	    NP: (^ OBJ) = !
		(! CASE) = acc
 	  | P: ^ = ! "head of PP" 
	       (! PTYPE) =c nosem; "non-semantxic type, OBL"
 	    NP
 	  }.


  METARULEMACRO(_CAT _BASECAT _RHS) = "applies to all rules in the grammar"

    { "just use the rule as stated"
      "don't do anything to it; ALWAYS include this option"

      _RHS

     |"if it is an NP or an N, pass it to the NP
      coordination rule"
      "COM{EX RULE NP: the girl and the boy}"

      e: _CAT $c { NP N };
      @(NPCOORD _CAT)

     |"if it is any other category, pass it to
      the same category coordination rule"
      "COM{EX RULE S: the girl sleeps and walks.}"
      "COM{EX RULE PP: with the girl and in the park}"

      e: _CAT ~$ { NP N };
      @(SCCOORD _CAT)

     |"allow bracketing around any category"
      "COM{EX RULE S: [the girl] sleeps.}"
      "COM{EX RULE S: boys baked [the bananas in the cake].}"

      LB: @(OT-MARK GenBadPunct); "preceding quote mark"
                                  "disprefer in generation"
      _CAT: @PUSHUP; "this pushes the quotes to the top
                      to avoid vacuous ambiguity for things like:
                      COM{EX RULES NP: [cakes])"
      RB "following quote mark"}.

"Coordination rules"

NPCOORD(_CAT) = "coordination of nominals"
   "COM{EX RULE NP: girls and boys}"
   "This differs from SCCOORD in that the conjunction provides NUM pl to
   the resulting coordinated f-structure and the person features are
   resolved for the noun phrase."

   _CAT: @IN-SET  "first nominal"
         @NP-CONJUNCT; "calls person resolution template"

   CONJnp: @PUSHUP; "conjunction"
           "PUSHUP avoids vacuous ambiguity in constructions like:
            COM{EX RULES NP: girls and boys}"

   _CAT: @IN-SET "second nominal"
         @NP-CONJUNCT.

SCCOORD(_CAT) = "coordination of non-nominals"
  "COM{EX RULES PP: with girls and with boys}"
  "COM{EX RULES S: girls sleep and boys sleep.}"
  "no features other than a COORD-FORM are provided to the coordinated
  f-structure."

   _CAT: @IN-SET; "first constituent"
   (COMMA: @(OT-MARK GenBadPunct)) "optional comma; 
                                    disprefered in generation"
                       "COM{EX RULES S: girls sleep, and boys sleep.}"

   CONJ: @PUSHUP; "conjunction"
         "PUSHUP avoids vacuous ambiguity in constructions like:
         COM{EX RULES S: boys walk and sleep.}" 

   _CAT: @IN-SET "second constituent".

----

DEMO ENGLISH LEXICON (1.0)

"nouns"

"took out all names and nouns because they are now handled via the morphology"

"all verbs here -- still need to convert fully to just have lemmas"

"verbs with clausal arguments"

say 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(say,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).

think 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
	      %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(think,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).

ensure    V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      :$ lam(P,lam(X,lam(S,merge(drs([],[pred(ensure,S),rel(arg1,S,X)]),drs([],[cont(S,app(P,S))]))))) :
	      ((%s_s -o %s_t) -o (s::(^ SUBJ)_e -o ((s::^ SIT)_s -o (s::^ SIT)_t))).


convince  V-S XLE (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
          @ATTITUDE
		  (^ XCOMP SUBJ) = (^OBJ)
		  :$ lam(X, lam(Y,lam(P,lam(S,drs([],[pred(convince,S), rel(arg1,X,S), rel(arg2,Y,S), cont(S,app(app(P,Y),S))]))))) :
		  (s:: (^SUBJ)_e -o (s::(^OBJ)_e -o ((s::(^XCOMP SUBJ)_e -o ((s::(^ XCOMP) SIT) _s -o (s::(^ XCOMP) SIT)_t)) -o ((s::^ SIT)_s -o (s::^ SIT)_t)))).


try 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  :$ lam(X,lam(P,lam(S,drs([],[pred(try,S),rel(arg1,S,X),cont(S,app(app(P,X),S))])))) :
		  (s::(^XCOMP SUBJ)_e -o ((s::(^ XCOMP SUBJ)_e -o ((s::(^ XCOMP) SIT)_s -o (s::(^ XCOMP) SIT)_t)) -o ((s::^ SIT)_s -o (s::^ SIT)_t))).

seem 	  V-S XLE (^PRED) = '%stem<(^SUBJ)>(^XCOMP)'
          @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  :$ lam(P,lam(S,drs([],[pred(seem,S),cont(S,app(P,S))]))) :
		  (((s::(^ XCOMP) SIT)_s -o (s::(^ XCOMP) SIT)_t) -o ((s::^ SIT)_s -o (s::^ SIT)_t)).

"want is a copy of try"
want	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  :$ lam(X,lam(P,lam(S,drs([],[pred(want,S),rel(arg1,S,X),cont(S,app(app(P,X),S))])))) :
		  (s::(^XCOMP SUBJ)_e -o ((s::(^ XCOMP SUBJ)_e -o ((s::(^ XCOMP) SIT)_s -o (s::(^ XCOMP) SIT)_t)) -o ((s::^ SIT)_s -o (s::^ SIT)_t))).


believe V-S XLE @(PASS (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>')
          @(XCOMP-OBJ-PASSIVE-ARGS %arg1 %arg2 %arg3)
		  @ATTITUDE
		  (^ XCOMP SUBJ) = %arg2
		  :$ lam(X, lam(Y,lam(P,lam(S,drs([],[pred(believe,S), rel(arg1,X,S), rel(arg2,Y,S), cont(S,app(app(P,Y),S))]))))) :
          (s::%arg1_e -o (s::%arg2_e -o ((s::(^XCOMP SUBJ)_e -o ((s::(^ XCOMP) SIT) _s -o (s::(^ XCOMP) SIT)_t)) -o ((s::^ SIT)_s -o (s::^ SIT)_t)))).

"Intransitives"

appear 	  V-S XLE @(INTRANS-EV %stem).

disappear V-S XLE @(INTRANS-EV %stem).

laugh 	  V-S XLE @(INTRANS-EV %stem).
	       
sleep 	  V-S XLE @(INTRANS-EV %stem).

wait 	  V-S XLE { @(INTRANS-EV wait) | 
		@(INTRANS-OBL wait) 
		"this is the non-semantic OBL wait on a customer use"
		(^ OBL PFORM) =c on
		(^ PSEM) =c nosem }.

"Optional transitives"

drinks 	  V-S XLE @(OPT-TRANS-EV %stem).

eat 	  V-S XLE @(OPT-TRANS-EV %stem).

escape 	  V-S XLE @(OPT-TRANS-EV %stem).

"Transitives"

become 	  V-S XLE @(TRANS-EV %stem).

devour 	  V-S XLE @(TRANS-EV %stem).

lick 	  V-S XLE @(TRANS-EV %stem).

hate 	  V-S XLE @(TRANS-EV %stem).  "using the morphological analyzer"

hug V-S XLE @(TRANS-EV %stem);ETC.

implement V * @(TRANS see)
	      @VPRES
	      @BARE-AGR. 

love 	  V-S XLE @(TRANS-EV %stem).

receive   V-S XLE @(TRANS %stem).

see 	  V-S XLE @(TRANS-EV %stem).

"Ditransitives"

give 	  V-S XLE @(DITRANS-EV give).



"to be"

be   V-S XLE   { (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'         "for nouns without arguments"
               @(EVENT %stem)                              "(^PRED) = 'be<(^SUBJ)(^PREDLINK)>' ??"
              |
               (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'       "so that adjectives can take their own arguments"
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)}.       "EX.: There is an example; to allow expletives with an NP"




"adjectives --- should really be done via the morphology, like the nouns"
"He is a fatter politician than the other guy."
greatest  A * (^DEGREE) = superlative
               @(PRED great).
               "is atype important here?"


greater  A * (^DEGREE) = comparative
               { @(PRED great)
               (^ATYPE) = attributive
               | (^ATYPE) = predicative
               (^ PRED)='great <(^ OBL-COMP)>' "wie man das mit dem optionalen Argument macht? - kann man sich nochmal anschauen"
               }.

great   A * (^DEGREE) = positive
               { @(PRED great)
               (^ATYPE) = attributive
               | (^ATYPE) = predicative
               (^ PRED)='great <(^OBL-COMP)>'
               }.

small 	  A * @(PRED small)
              (^DEGREE) = positive.

smart 	  A * @(PRED smart). 

grey 	  A * @(PRED grey).

Italian   A * @(PRED italian); ETC.

"not the revised semantics"

big 	  A * @(PRED big)
	      :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
	      ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.

black 	  A * @(PRED black)
	      :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
	      ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.

scottish  A * @(PRED scottish)
	      :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
	      ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.

trustworthy A * @(PRED trustworthy)
		  :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
		  ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.

alleged   A * @(PRED alleged)
	      :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
	      ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.

former 	  A * @(PRED former)
	      :$ lam(Q,lam(X,merge(drs([],[pred(%stem,X)]),app(Q,X)))) :
	      ((s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t) -o (s::(ADJUNCT $ ^)_e -o s::(ADJUNCT $ ^)_t)) || noscope.


"adverbs --- should really be done via the morphology, like the nouns"

quickly   ADV * @(PRED quickly). 

very 	  ADV * @(PRED very).


"comparison constructions"

than      CComp * (^PRED) = 'than<(^OBJ)>'
                  "(^DEGREE) =c comparative." "da muss man noch schauen wie.."
                  ((OBL-COMP ^) DEGREE) =c comparative.
                  "(^ ADJUNCT $ DEGREE) =c comparative"                         "funktioniert nicht mit he is a greater politican than..."

as        CComp * (^PRED) = 'as<(^OBJ)>'
                  (^DEGREE) ~=c comparative
                  (^DEGREE) ~=c superlative;
          ADVComp * @(PRED as)
                  (^DEGREE) ~=c comparative
                  (^DEGREE) ~=c superlative.


"prepositions"

by 	  P * @(PREP by). 

to 	  P * @(PREP to); 
	  PARTinf * (^ VFORM) =c inf.

on 	  P * @(PREP on). 

in 	  P * @(PREP in). 

with 	  P * @(PREP with)
	  @(PREP-SEM with). 


"auxiliaries"

"was 	  AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
		{ (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg."

is 	  AUX * @(TENSE pres)
		{ (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg.

"pronouns (not complete)"

I 	  PRON * @(PRON I 1 sg pers) 
		 @(CASE nom).

You	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

you	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

He 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

he 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

She 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

she 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

it	  PRON * @(PRON it 3 sg pers). 

We 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

we 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

They 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom). 

they 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom).

My 	  PRON * @(POSS-PRON I sg 1).   "'I' or 'my' ??"

my 	  PRON * @(POSS-PRON I sg 1).

his 	  PRON * @(POSS-PRON he sg 3).

Her 	  PRON * {@(PRON she sg 3 pers)
		    |@(POSS-PRON she sg 3)}.

her 	  PRON * @(PRON her 3 sg pers).

Him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).

him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).



"expletive"
There   PRON *   (^PRON-TYPE) = expl_
	             (^PRON-FORM) = it
	             {(^NUM) =sg |(^NUM) = pl}.

"relative"
who PRON *      (^PRON-TYPE) = rel
                (^PRON-FORM) = who
                (^PRED) = 'PRO'
                "(^NUM)".


"determiners"

the 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +        "encoded as det-type in inness"
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)) || noscope.

The 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)) || noscope.


a 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


an 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).
	
A 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

An 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,merge(drs([X],[]),merge(app(P,X),app(Q,X))))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).



more  D * (^DEF) = - "this indefinite only marks plurals"
          (^NUM) = pl
          (^DEGREE) = comparative. "marks the NP as comparative to allow CPComps to apply"

More  D * (^DEF) = - "this indefinite only marks plurals"
          (^NUM) = pl
          (^DEGREE) = comparative. "marks the NP as comparative to allow CPComps to apply"


"changed to spec-quant"
every 	  D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

Every 	   D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q) 
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


" new quantifiers"

some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

Some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

"preliminary semantics for all, copied from every"
"also for Fracas Testsuite"
"EX: All mice are animals"
all 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).

All 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      :$ lam(P,lam(Q,drs([],[imp(merge(drs([X],[]),app(P,X)),app(Q,X))]))) :
	      ((s::^_e -o s::^_t) -o ((s::^_e -o %q_t) -o %q_t)).


"each"
Each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q).

each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q).

"complementizers"

that  C * (^COMP-FORM) = that. 


"conjunctions"

and 	  CONJ * @(COORD-FORM %stem);
	  CONJnp * @(COORD-FORM %stem) @(NUM pl).

or 	  CONJ * @(COORD-FORM %stem);
	  CONJnp * @(COORD-FORM %stem) @(NUM pl).


"punctuation, now with some functional information"

. 	  PERIOD * (^ STMT-TYPE) = declarative. 

, 	  COMMA * . 

! 	  EXCL * (^ STMT-TYPE) = exclamation. 




----

GLUE   BASIC   TEMPLATES (1.0)

   LLIMP(N L R) = (N ANT) = L
	  (N CONS) = R.
	      
   LLATOM(N L T) = (N RESOURCE) = L
	  (N TYPE) = T.

   LLCLOSURE(G) = G $ (g::* GLUE).

   GLUE-MEANING(R M) = 
	  (R MEANING) = M.

  NOSCOPE(G) = (G NOSCOPE) = +.  

   NAME-SCOPE(UP NAME) =
   %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT| PREDLINK}+ ^)
   (%name FIN) =c +
   NAME  = (s::%name SIT)
   (s::^ QUANT-SCOPE) = NAME.

     QUANT-SCOPE(UP NAME) =
  	  %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT | PREDLINK}+ ^) "PREDLINK added so determiners are compatible eg. 'Mary is a dog'"
  	  (s::%name EV TYPE) =c eventuality
  	  NAME = (s::%name SIT)
  	  (s::^ QUANT-SCOPE) = NAME.

" Why does the below not work?
   QUANT-SCOPE(UP NAME) =
	  NAME = s::({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT | PREDLINK}+ ^)
	  (NAME EV TYPE) =c eventuality
	  (s::^ QUANT-SCOPE) = (NAME SIT).
	  "

   ATTITUDE = (s::^ SIT) = %s
   	      (s::^ EV TYPE) = eventuality
	  {
	    (^ ROOT)
	    @TENSE-CLOSURE
	   |
	    ~[(^ ROOT)]
	    }.
	  
   EVENT(REL) =
	  (s::^ EV TYPE) = eventuality
	  (s::^ SIT) = %s
	  :$ lam(V,drs([],[pred(REL,V)])) : ((s::^ EV)_v -o (s::^ EV)_t),
	  :$ lam(V,lam(S,merge(drs([E],[rel(partOf,E,S)]),app(V,E)))) : (((s::^ EV)_v -o (s::^ EV)_t) -o (%s_s -o %s_t)),
	  { 
	    (^ ROOT)
	    @TENSE-CLOSURE
	   |
	    ~[(^ ROOT)]}.

   PREP-SEM(P) =
             {
	     %scope = (s::(ADJUNCT ^) EV)
	     (%scope TYPE) =c eventuality
	    :$ lam(U,lam(V,lam(E,merge(drs([],[]),merge(app(U,E),app(V,E)))))) :
	    ((%scope_v -o s::^_t) -o ((%scope_v -o %scope_t) -o (%scope_v -o %scope_t))),
	    :$ lam(Y,lam(X,drs([],[rel(P,X,Y)]))) : (s::(^OBJ)_e -o (%scope_v -o s::^_t)),
	    |
	    %scope = s::(ADJUNCT ^)
	    (%scope TYPE) =c entity
	    :$ lam(U,lam(V,lam(E,merge(drs([],[]),merge(app(U,E),app(V,E)))))) :
	    ((s::(ADJUNCT ^)_e -o s::^_t) -o ((s::(ADJUNCT ^)_e -o %scope_t) -o (s::(ADJUNCT ^)_e -o %scope_t))) || noscope,
	    :$ lam(Y,lam(X,drs([],[rel(P,X,Y)]))) : (s::(^OBJ)_e -o (s::(ADJUNCT ^)_e -o s::^_t)),
	     }.

 TENSE-CLOSURE = %tense = (s::^ TEMP-REF EVAL)
 :$ lam(P,merge(drs([T],[eq(T,now)]),app(P,T))) : ((%tense_s -o %tense_t) -o s::^_t).

   "Templates for argument structure. Need to be separate to avoid trouble with local names"
   ARG1(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg1,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.

   ARG2(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg2,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.

   ARG3(ARG) =
       :$ lam(V,lam(X,lam(E,merge(app(V,E),drs([],[rel(arg3,E,X)]))))) :
       (((s::^ EV)_v -o (s::^ EV)_t) -o (s::ARG_e -o ((s::^ EV)_v -o (s::^ EV)_t))) || noscope.



----

