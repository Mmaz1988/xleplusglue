DEMO   ENGLISH   CONFIG (1.0)
  ROOTCAT   ROOT.  "changed to ROOT from S"
  FILES common.templates.lfg  morph_fracas.lfg.
  LEXENTRIES   (DEMO ENGLISH) (MORPH ENGLISH).
  TEMPLATES (DEMO ENGLISH) (GLUE BASIC) (STANDARD COMMON).  "added common ParGram templates"
  RULES   (DEMO ENGLISH) (MORPH ENGLISH).
  MORPHOLOGY (DEMO ENGLISH).
  GOVERNABLERELATIONS    SUBJ OBJ OBJ2 COMP XCOMP OBL OBL-?+ PREDLINK.
  SEMANTICFUNCTIONS    ADJUNCT  TOPIC FOCUS POSS STANDARD.
  NONDISTRIBUTIVES   NUM PERS COORD-FORM.
  EPSILON   e.
  OPTIMALITYORDER NOGOOD  PPadj +PPattach +PPpassiv +sg-imp.
  GENOPTIMALITYORDER GenBadPunct NOGOOD +Punct.


----

DEMO   ENGLISH   RULES (1.0)

   ROOT --> "can have other things here as well, imperatives, etc." 
 	  { S: (^ ROOT) = +;
 	    (PERIOD: @(OT-MARK Punct)) "prefer for generation"
 	  | Simp}. 

  Simp --> e: (^ SUBJ PRED) = 'pro'
	       (^ SUBJ PERS) = 2; 
 	  VP
 	  EXCL.  "obligatory exclamation mark"

   S --> NP: (^ SUBJ)=!
	     (! CASE)=nom;
 	 VP: (^ TNS-ASP TENSE) "require that sentences have tense"
 	     (^ FIN) = +
	     (s::^ TEMP-REF EVAL) = %eval. "Tense needs to be evaluated against sth."

	 
   VP --> (AUX) "auxiliary introduced for passive" 
 	  V: ^=!;
 	  ({NP: (^ OBJ)=! "direct object"
	       (! CASE)=acc |
	       NP: (^ PREDLINK) = ! "to be + ..."
	       "referential subject must match object in number "
	       "eg. Mary is a dog vs *Mary is the dogs"
	       @(IF (^SUBJ NUM) (^SUBJ NUM)=c(^PREDLINK NUM)) |
	       AP[predicative]: (^ PREDLINK) = !
	            })
 	  (NP: (^ OBJ2) = !)


	  "secondary object"
 	  PP*: { ! $ (^ ADJUNCT) "PPs can be all types of adjuncts"
		 (! PTYPE) =c sem "only semantic PPs here"
		 "@(OT-MARK PPadj)" "disprefer adjunct PPs" 
	       | (^ OBL) = ! "or a a general oblique"
	       };
 	  (PP: (^ OBL-TO) = ! "special obl for ditransitives"
	       "example of a constraining equation: require a value with =c"
	       (! PFORM) =c to )
 	  (PP: (^ OBL-AG) = ! "oblique agent of passive" 
	       "example of a constraining equation: require a value with =c" 
	       (! PFORM) =c by
	       @(OT-MARK PPpassiv))
 	  ({ CP: (^ COMP) = !
 	  	|
 		VPinf: (^XCOMP) = !
 		 (! FIN) = -
		 (! VFORM) = inf
 		 (s::^ TEMP-REF) = (s::(^XCOMP) EVAL)}
 		 )

    (ADVP: ! $ (^ ADJUNCT))

    "rule for phrasal comparative"
    "EX: He laughs greater than her."
    "somewhat preliminary, should not be 'predicative', works for the moment though"
    (AP[predicative]: ! $ (^ ADJUNCT)).

   ADVP --> VP: (^ SUBJ PRED) = 'pro'
   	    	~[(^ TNS-ASP TENSE)].

   CP -->  C
	   S. 


  "aber who sollte ja eigentlich zum gleichen subject wie der main clause referen"
  "get features of the NP on the who somehow -> NUM und PERS"
   CPrel --> NP: (! PRON-TYPE) =c rel
                 (^ SUBJ) = !
                 "(^NUM ADJUNCT SUBJ) = (!NUM)"
                 ;
              VP.


   VPinf --> PARTinf VP. 


   NP --> "either a full NP or a PRON"
 	  { ( {D: ^=! | PRON})
	    "optional determiner"
 	     AP[attributive]*: ! $ (^ ADJUNCT); "introducing adjectives in sets"

 	     N: ^=!;
	    "head of NP"

	    "comparison with whole NPs"
	    "EX: He is a fatter politician than him."
        (CPComp: (^ OBL-COMP) = !)


	    (CPrel: ! $ (^ ADJUNCT))

 	    PP*: ! $ (^ ADJUNCT) "PPs modifying NPs" 
		(! PTYPE) =c sem "have to be semantic"
		 "@(OT-MARK PPattach)" "prefer PPs attached to NPs"
 	  | PRON}. 


   AP[_type $ {attributive predicative}] -->

        (ADVComp: _type = predicative
                  ! $ (^ ADJUNCT))

        ADV*: ! $ (^ ADJUNCT);

        A*: ^=!;

        "than-comparatives as adjuncts on the AP"
        "type of comparative is handled in the lexicon"
        "EX1: The tree is greater than the plant."
        "EX2: The tree is (as) great (as the plant)."
        (CPComp: _type = predicative
                 (^ OBL-COMP) = !)
        (COMMA).



   "rule for comparison constructions"
   "EX: He is greater than the dog (is)."
   CPComp --> CComp
 	      { NP: (^ OBJ) = !
		        (! CASE) = acc
 	      |
 	        "for elliptical constructions."
            "EX: He is greater than the dog is (great)."
 	        S: (^ OBJ) = !
 	      }.


   PP --> { P: ^ = ! "head of PP"
	       (! PTYPE) =c sem; "semantic type, Adjunct"
 	    NP: (^ OBJ) = !
		(! CASE) = acc
 	  | P: ^ = ! "head of PP" 
	       (! PTYPE) =c nosem; "non-semantxic type, OBL"
 	    NP
 	  }.


  METARULEMACRO(_CAT _BASECAT _RHS) = "applies to all rules in the grammar"

    { "just use the rule as stated"
      "don't do anything to it; ALWAYS include this option"

      _RHS

     |"if it is an NP or an N, pass it to the NP
      coordination rule"
      "COM{EX RULE NP: the girl and the boy}"

      e: _CAT $c { NP N };
      @(NPCOORD _CAT)

     |"if it is any other category, pass it to
      the same category coordination rule"
      "COM{EX RULE S: the girl sleeps and walks.}"
      "COM{EX RULE PP: with the girl and in the park}"

      e: _CAT ~$ { NP N };
      @(SCCOORD _CAT)

     |"allow bracketing around any category"
      "COM{EX RULE S: [the girl] sleeps.}"
      "COM{EX RULE S: boys baked [the bananas in the cake].}"

      LB: @(OT-MARK GenBadPunct); "preceding quote mark"
                                  "disprefer in generation"
      _CAT: @PUSHUP; "this pushes the quotes to the top
                      to avoid vacuous ambiguity for things like:
                      COM{EX RULES NP: [cakes])"
      RB "following quote mark"}.

"Coordination rules"

NPCOORD(_CAT) = "coordination of nominals"
   "COM{EX RULE NP: girls and boys}"
   "This differs from SCCOORD in that the conjunction provides NUM pl to
   the resulting coordinated f-structure and the person features are
   resolved for the noun phrase."

   _CAT: @IN-SET  "first nominal"
         @NP-CONJUNCT; "calls person resolution template"

   CONJnp: @PUSHUP; "conjunction"
           "PUSHUP avoids vacuous ambiguity in constructions like:
            COM{EX RULES NP: girls and boys}"

   _CAT: @IN-SET "second nominal"
         @NP-CONJUNCT.

SCCOORD(_CAT) = "coordination of non-nominals"
  "COM{EX RULES PP: with girls and with boys}"
  "COM{EX RULES S: girls sleep and boys sleep.}"
  "no features other than a COORD-FORM are provided to the coordinated
  f-structure."

   _CAT: @IN-SET; "first constituent"
   (COMMA: @(OT-MARK GenBadPunct)) "optional comma; 
                                    disprefered in generation"
                       "COM{EX RULES S: girls sleep, and boys sleep.}"

   CONJ: @PUSHUP; "conjunction"
         "PUSHUP avoids vacuous ambiguity in constructions like:
         COM{EX RULES S: boys walk and sleep.}" 

   _CAT: @IN-SET "second constituent".

----
DEMO   ENGLISH   TEMPLATES (1.0)

   NP-CONJUNCT = "provides person resolution features for nominal
	  coordination" 
	  
	  { "if either conjunct is 1st person; the whole NP is"
	    "EX: the boys and me}"
	    (! PERS)=c 1
	    (^ PERS)=1
	   |"if a conjunct is 2nd person and the NP is not
	    already 1st person, make it 2nd person"
	    (! PERS)=c 2
	    { (^ PERS)=c 1 "one conjunct was 1st person"
	      "EX: you and I}"
	     |(^ PERS)=2 } "else assign 2nd person"
	    "EX: you and the boys}"
	   |"otherwise, the NP is 3rd person"
	    "EX: the boys and her}"
	    (^ PERS)=3}.

   OT-MARK(_mark) = "assigns an OT mark, from common templates"
	  _mark $ o::*.

   PASS(FRAME) = { FRAME "no passive, just give back subcat frame"
	    (^ PASSIVE) = - "no passive"
	  | FRAME "passive"
	    (^ PASSIVE) = + "mark as such"
	    (^ PARTICIPLE) =c past "make sure to have a past participle"
	    (^ OBJ)-->(^ SUBJ) "obj goes to subj"
	    { (^ SUBJ)-->(^ OBL-AG) "either make subj obl-ag"
	    | (^ SUBJ)--> NULL "or delete"
	    }
	  }. 

   DAT-SHIFT(SCHEMATA) = { SCHEMATA
	    (^ DATIVE-SHIFT) = -
	  | SCHEMATA
	    (^ DATIVE-SHIFT) = +
	    (^ OBJ)-->(^ OBJ2)
	    (^ OBL-TO)-->(^ OBJ)}.

   """Subcategorization templates"""

   "lambda DRT"
   DITRANS-EV(P) = @(PASS @(DAT-SHIFT (^ PRED)='P<(^ SUBJ) (^ OBJ) (^ OBL-TO)>'))
	       @(DITRANS-PASSIVE-ARGS %arg1 %arg2 %arg3)
	       @(EVENT P)
	       @(ARG1 %arg1)
	       @(ARG2 %arg2)
	       @(ARG3 %arg3).

	  	       
   "lambda DRT"
   TRANS-EV(P) = @(PASS (^ PRED)='P<(^SUBJ) (^OBJ)>')
   	  @(TRANS-PASSIVE-ARGS %arg1 %arg2)
	  @(EVENT P)
	  @(ARG1 %arg1)
	  @(ARG2 %arg2).



   "lambda DRT"
   INTRANS-EV(P) = (^ PRED) = 'P<(^SUBJ)>'
	  @(EVENT P)
	  @(ARG1 (^ SUBJ)).

   INTRANS-OBL(P) = (^ PRED) = 'P<(^SUBJ)(^OBL)>'.

   "FOL + lambda calculus"
   OPT-TRANS(P) = { (^ PRED) = 'P<(^SUBJ)(^OBJ)>' "P is a variable"
	    @(LLCLOSURE %mc676)
@(LLATOM %mc672 s::(^SUBJ) e)
@(LLATOM %mc673 s::(^OBJ) e)
@(LLATOM %mc674 s::^ t)
@(LLIMP %mc675 %mc673 %mc674)
@(LLIMP %mc676 %mc672 %mc675)
@(CONCAT  `[  `/ x `_ e `.  `[  `/ y `_ e `. P `( x `, y `)  `]  `]  %mc677)
@(GLUE-MEANING %mc676 %mc677)	          | (^ PRED) = 'P<(^SUBJ)>'
		  @(LLCLOSURE %mc680)
@(LLATOM %mc678 s::(^ SUBJ) e)
@(LLATOM %mc679 s::^ t)
@(LLIMP %mc680 %mc678 %mc679)
@(CONCAT  `[  `/ x `_ e `. P `( x `)  `]  %mc681)
@(GLUE-MEANING %mc680 %mc681)		  }.  "this template takes one argument:  P"

   "lambda DRT"
   OPT-TRANS-EV(P) = { @(TRANS-EV P)
	   |
	    @(INTRANS-EV P)
	  }. 

""" Argument structure templates """
   
   TRANS-PASSIVE-ARGS(ARG1 ARG2) = { 
	    (^ PASSIVE) =c - 
	    ARG1 = (^ SUBJ)
	    ARG2 = (^ OBJ)
	   |
	    (^ PASSIVE) =c +
	    { 
	      (^OBL-AG) = ARG1 |
	      ~[(^OBL-AG)]
	      ARG1 = %empty
	      @(LLCLOSURE %mc686)
@(LLATOM %mc682 s::%empty e)
@(LLATOM %mc683 s::^ t)
@(LLIMP %mc684 %mc682 %mc683)
@(LLATOM %mc685 s::^ t)
@(LLIMP %mc686 %mc684 %mc685)
@(CONCAT lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( Q `, X `)  `)  `)  %mc687)
@(GLUE-MEANING %mc686 %mc687)
@(NOSCOPE %mc686)	    }
	    ARG2 = (^ SUBJ)
	  }.

   DITRANS-PASSIVE-ARGS(ARG1 ARG2 ARG3) = {
	    (^ PASSIVE) =c -
	    ARG1 = (^ SUBJ)
	    {
	      (^ DATIVE-SHIFT) =c -
	      ARG2 = (^ OBJ)
	      ARG3 = (^ OBL-TO)
	     |
	      (^ DATIVE-SHIFT) =c +
	      ARG3 = (^ OBJ)
	      ARG2 = (^ OBJ2)
	    }
	   |
	    (^ PASSIVE) =c +
	    {
	      (^OBL-AG) = ARG1 |
	      ~[(^OBL-AG)]
	      ARG1 = %empty
	      @(LLCLOSURE %mc692)
@(LLATOM %mc688 s::%empty e)
@(LLATOM %mc689 s::^ t)
@(LLIMP %mc690 %mc688 %mc689)
@(LLATOM %mc691 s::^ t)
@(LLIMP %mc692 %mc690 %mc691)
@(CONCAT lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( Q `, X `)  `)  `)  %mc693)
@(GLUE-MEANING %mc692 %mc693)
@(NOSCOPE %mc692)	    }
	    {
	      (^ DATIVE-SHIFT) =c -
	      ARG2 = (^ SUBJ)
	      ARG3 = (^ OBL-TO)
	     |
	      (^ DATIVE-SHIFT) =c +
	      ARG2 = (^ OBJ2)
	      ARG3 = (^ SUBJ)
	    }
	  }.


  XCOMP-OBJ-PASSIVE-ARGS(ARG1 ARG2 ARG3) = {
    (^ PASSIVE) =c -
    ARG1 = (^ SUBJ)
    ARG2 = (^ OBJ)
    ARG3 = (^ XCOMP)
   |
    (^ PASSIVE) =c +
    {
      (^OBL-AG) = ARG1 |
      ~[(^OBL-AG)]
      ARG1 = %empty
      @(LLCLOSURE %mc692)
@(LLATOM %mc688 s::%empty e)
@(LLATOM %mc689 s::^ t)
@(LLIMP %mc690 %mc688 %mc689)
@(LLATOM %mc691 s::^ t)
@(LLIMP %mc692 %mc690 %mc691)
@(CONCAT lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( Q `, X `)  `)  `)  %mc693)
@(GLUE-MEANING %mc692 %mc693)
@(NOSCOPE %mc692)    }
    ARG2 = (^ SUBJ)
    ARG3 = (^ XCOMP)
  }.

   """Functional feature templates"""

   CASE(C) = (^ CASE) = C.   

   VPRES = { (^VFORM) ~= inf
	    @(TENSE pres)
	    @(MOOD indicative)
	  |
	  (^VFORM) = inf}.

   VPAST = @(TENSE past) 
	  @(MOOD indicative). 

   VPROG = (^ TNS-ASP PROG) = +_.

   PRED(P) = (^ PRED) = 'P'. 

   PASTP = (^ PARTICIPLE) = past. 

   BARE-AGR = { (^VFORM) ~= inf
	    { (^ SUBJ NUM) = pl "either it is plural"
	    | (^ SUBJ PERS) ~= 3 "or singular and not 3rd person"
	      (^ SUBJ NUM) = sg
	      @(OT-MARK sg-imp) "prefer a singular imperative"
	    }
	  | (^VFORM) = inf}.

   S-AGR = (^ SUBJ PERS) = 3 "for verbs in -s"
	  (^ SUBJ NUM) = sg.

"template for ntypes, called NPOS here because of clash with common templates"

   NPOS(N) = (^ NTYPE) = N. 

   PREP(P) = "template for most prepositions"
	  { (^ PRED) = 'P<(^OBJ)>' 
	    (^ PTYPE) = sem
	  | (^ PTYPE) = nosem
	    (^ PFORM) = P}.

"template for pronouns of all types" 

   PRON(P Z N T) = (^ PRED) = 'P'
	  (^ NUM) = N
	  (^ PERS) = Z
	  (^ PRON-TYPE) = T
	  (^ NTYPE) = pron. 

"template for possessive pronouns, as these have conflicting heads in regular template"

    POSS-PRON(P N Z) = (^ POSS PRED) = 'P'
	  	   (^ POSS NUM) = N
	  	   (^ POSS PERS) = Z
	  	   (^ POSS PRON-TYPE) = poss
	  	   (^ POSS NTYPE) = pronoun.

   DEF = (^ DEF).


----

DEMO ENGLISH LEXICON (1.0)

"nouns"

"took out all names and nouns because they are now handled via the morphology"

"all verbs here -- still need to convert fully to just have lemmas"

"verbs with clausal arguments"

say 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      @(LLCLOSURE %mc708)
@(LLATOM %mc700 %s s)
@(LLATOM %mc701 %s t)
@(LLIMP %mc702 %mc700 %mc701)
@(LLATOM %mc703 s::(^ SUBJ) e)
@(LLATOM %mc704 (s::^ SIT) s)
@(LLATOM %mc705 (s::^ SIT) t)
@(LLIMP %mc706 %mc704 %mc705)
@(LLIMP %mc707 %mc703 %mc706)
@(LLIMP %mc708 %mc702 %mc707)
@(CONCAT lam `( P `, lam `( X `, lam `( S `, merge `( drs `(  `[  `]  `,  `[ pred `( say `, S `)  `, rel `( arg1 `, S `, X `)  `]  `)  `, drs `(  `[  `]  `,  `[ cont `( S `, app `( P `, S `)  `)  `]  `)  `)  `)  `)  `)  %mc709)
@(GLUE-MEANING %mc708 %mc709).

think 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
	      %s = (s::(^ COMP) TEMP-REF EVAL)
	      @(LLCLOSURE %mc718)
@(LLATOM %mc710 %s s)
@(LLATOM %mc711 %s t)
@(LLIMP %mc712 %mc710 %mc711)
@(LLATOM %mc713 s::(^ SUBJ) e)
@(LLATOM %mc714 (s::^ SIT) s)
@(LLATOM %mc715 (s::^ SIT) t)
@(LLIMP %mc716 %mc714 %mc715)
@(LLIMP %mc717 %mc713 %mc716)
@(LLIMP %mc718 %mc712 %mc717)
@(CONCAT lam `( P `, lam `( X `, lam `( S `, merge `( drs `(  `[  `]  `,  `[ pred `( think `, S `)  `, rel `( arg1 `, S `, X `)  `]  `)  `, drs `(  `[  `]  `,  `[ cont `( S `, app `( P `, S `)  `)  `]  `)  `)  `)  `)  `)  %mc719)
@(GLUE-MEANING %mc718 %mc719).

ensure    V-S XLE (^PRED) = '%stem<(^SUBJ)(^COMP)>'
          @ATTITUDE
          %s = (s::(^ COMP) TEMP-REF EVAL)
	      @(LLCLOSURE %mc728)
@(LLATOM %mc720 %s s)
@(LLATOM %mc721 %s t)
@(LLIMP %mc722 %mc720 %mc721)
@(LLATOM %mc723 s::(^ SUBJ) e)
@(LLATOM %mc724 (s::^ SIT) s)
@(LLATOM %mc725 (s::^ SIT) t)
@(LLIMP %mc726 %mc724 %mc725)
@(LLIMP %mc727 %mc723 %mc726)
@(LLIMP %mc728 %mc722 %mc727)
@(CONCAT lam `( P `, lam `( X `, lam `( S `, merge `( drs `(  `[  `]  `,  `[ pred `( ensure `, S `)  `, rel `( arg1 `, S `, X `)  `]  `)  `, drs `(  `[  `]  `,  `[ cont `( S `, app `( P `, S `)  `)  `]  `)  `)  `)  `)  `)  %mc729)
@(GLUE-MEANING %mc728 %mc729).


convince  V-S XLE (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>'
          @ATTITUDE
		  (^ XCOMP SUBJ) = (^OBJ)
		  @(LLCLOSURE %mc742)
@(LLATOM %mc730 s:: (^SUBJ) e)
@(LLATOM %mc731 s::(^OBJ) e)
@(LLATOM %mc732 s::(^XCOMP SUBJ) e)
@(LLATOM %mc733 (s::(^ XCOMP) SIT)  s)
@(LLATOM %mc734 (s::(^ XCOMP) SIT) t)
@(LLIMP %mc735 %mc733 %mc734)
@(LLIMP %mc736 %mc732 %mc735)
@(LLATOM %mc737 (s::^ SIT) s)
@(LLATOM %mc738 (s::^ SIT) t)
@(LLIMP %mc739 %mc737 %mc738)
@(LLIMP %mc740 %mc736 %mc739)
@(LLIMP %mc741 %mc731 %mc740)
@(LLIMP %mc742 %mc730 %mc741)
@(CONCAT lam `( X `,  lam `( Y `, lam `( P `, lam `( S `, drs `(  `[  `]  `,  `[ pred `( convince `, S `)  `,  rel `( arg1 `, X `, S `)  `,  rel `( arg2 `, Y `, S `)  `,  cont `( S `, app `( app `( P `, Y `)  `, S `)  `)  `]  `)  `)  `)  `)  `)  %mc743)
@(GLUE-MEANING %mc742 %mc743).


try 	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  @(LLCLOSURE %mc754)
@(LLATOM %mc744 s::(^XCOMP SUBJ) e)
@(LLATOM %mc745 s::(^ XCOMP SUBJ) e)
@(LLATOM %mc746 (s::(^ XCOMP) SIT) s)
@(LLATOM %mc747 (s::(^ XCOMP) SIT) t)
@(LLIMP %mc748 %mc746 %mc747)
@(LLIMP %mc749 %mc745 %mc748)
@(LLATOM %mc750 (s::^ SIT) s)
@(LLATOM %mc751 (s::^ SIT) t)
@(LLIMP %mc752 %mc750 %mc751)
@(LLIMP %mc753 %mc749 %mc752)
@(LLIMP %mc754 %mc744 %mc753)
@(CONCAT lam `( X `, lam `( P `, lam `( S `, drs `(  `[  `]  `,  `[ pred `( try `, S `)  `, rel `( arg1 `, S `, X `)  `, cont `( S `, app `( app `( P `, X `)  `, S `)  `)  `]  `)  `)  `)  `)  %mc755)
@(GLUE-MEANING %mc754 %mc755).

seem 	  V-S XLE (^PRED) = '%stem<(^SUBJ)>(^XCOMP)'
          @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  @(LLCLOSURE %mc762)
@(LLATOM %mc756 (s::(^ XCOMP) SIT) s)
@(LLATOM %mc757 (s::(^ XCOMP) SIT) t)
@(LLIMP %mc758 %mc756 %mc757)
@(LLATOM %mc759 (s::^ SIT) s)
@(LLATOM %mc760 (s::^ SIT) t)
@(LLIMP %mc761 %mc759 %mc760)
@(LLIMP %mc762 %mc758 %mc761)
@(CONCAT lam `( P `, lam `( S `, drs `(  `[  `]  `,  `[ pred `( seem `, S `)  `, cont `( S `, app `( P `, S `)  `)  `]  `)  `)  `)  %mc763)
@(GLUE-MEANING %mc762 %mc763).

"want is a copy of try"
want	  V-S XLE (^PRED) = '%stem<(^SUBJ)(^XCOMP)>'
		  @ATTITUDE
		  (^ XCOMP SUBJ) = (^SUBJ)
		  @(LLCLOSURE %mc774)
@(LLATOM %mc764 s::(^XCOMP SUBJ) e)
@(LLATOM %mc765 s::(^ XCOMP SUBJ) e)
@(LLATOM %mc766 (s::(^ XCOMP) SIT) s)
@(LLATOM %mc767 (s::(^ XCOMP) SIT) t)
@(LLIMP %mc768 %mc766 %mc767)
@(LLIMP %mc769 %mc765 %mc768)
@(LLATOM %mc770 (s::^ SIT) s)
@(LLATOM %mc771 (s::^ SIT) t)
@(LLIMP %mc772 %mc770 %mc771)
@(LLIMP %mc773 %mc769 %mc772)
@(LLIMP %mc774 %mc764 %mc773)
@(CONCAT lam `( X `, lam `( P `, lam `( S `, drs `(  `[  `]  `,  `[ pred `( want `, S `)  `, rel `( arg1 `, S `, X `)  `, cont `( S `, app `( app `( P `, X `)  `, S `)  `)  `]  `)  `)  `)  `)  %mc775)
@(GLUE-MEANING %mc774 %mc775).


believe V-S XLE @(PASS (^PRED) = '%stem<(^SUBJ)(^OBJ)(^XCOMP)>')
          @(XCOMP-OBJ-PASSIVE-ARGS %arg1 %arg2 %arg3)
		  @ATTITUDE
		  (^ XCOMP SUBJ) = %arg2
		  @(LLCLOSURE %mc788)
@(LLATOM %mc776 s::%arg1 e)
@(LLATOM %mc777 s::%arg2 e)
@(LLATOM %mc778 s::(^XCOMP SUBJ) e)
@(LLATOM %mc779 (s::(^ XCOMP) SIT)  s)
@(LLATOM %mc780 (s::(^ XCOMP) SIT) t)
@(LLIMP %mc781 %mc779 %mc780)
@(LLIMP %mc782 %mc778 %mc781)
@(LLATOM %mc783 (s::^ SIT) s)
@(LLATOM %mc784 (s::^ SIT) t)
@(LLIMP %mc785 %mc783 %mc784)
@(LLIMP %mc786 %mc782 %mc785)
@(LLIMP %mc787 %mc777 %mc786)
@(LLIMP %mc788 %mc776 %mc787)
@(CONCAT lam `( X `,  lam `( Y `, lam `( P `, lam `( S `, drs `(  `[  `]  `,  `[ pred `( believe `, S `)  `,  rel `( arg1 `, X `, S `)  `,  rel `( arg2 `, Y `, S `)  `,  cont `( S `, app `( app `( P `, Y `)  `, S `)  `)  `]  `)  `)  `)  `)  `)  %mc789)
@(GLUE-MEANING %mc788 %mc789).

"Intransitives"

appear 	  V-S XLE @(INTRANS-EV %stem).

disappear V-S XLE @(INTRANS-EV %stem).

laugh 	  V-S XLE @(INTRANS-EV %stem).
	       
sleep 	  V-S XLE @(INTRANS-EV %stem).

wait 	  V-S XLE { @(INTRANS-EV wait) | 
		@(INTRANS-OBL wait) 
		"this is the non-semantic OBL wait on a customer use"
		(^ OBL PFORM) =c on
		(^ PSEM) =c nosem }.

"Optional transitives"

drinks 	  V-S XLE @(OPT-TRANS-EV %stem).

eat 	  V-S XLE @(OPT-TRANS-EV %stem).

escape 	  V-S XLE @(OPT-TRANS-EV %stem).

"Transitives"

become 	  V-S XLE @(TRANS-EV %stem).

devour 	  V-S XLE @(TRANS-EV %stem).

lick 	  V-S XLE @(TRANS-EV %stem).

hate 	  V-S XLE @(TRANS-EV %stem).  "using the morphological analyzer"

hug V-S XLE @(TRANS-EV %stem);ETC.

implement V * @(TRANS see)
	      @VPRES
	      @BARE-AGR. 

love 	  V-S XLE @(TRANS-EV %stem).

receive   V-S XLE @(TRANS %stem).

see 	  V-S XLE @(TRANS-EV %stem).

"Ditransitives"

give 	  V-S XLE @(DITRANS-EV give).



"to be"

be   V-S XLE   { (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'         "for nouns without arguments"
               @(EVENT %stem)                              "(^PRED) = 'be<(^SUBJ)(^PREDLINK)>' ??"
              |
               (^PRED) = '%stem<(^PREDLINK)>(^SUBJ)'       "so that adjectives can take their own arguments"
               (^SUBJ) = (^ PREDLINK SUBJ)
               @(EVENT %stem)}.       "EX.: There is an example; to allow expletives with an NP"




"adjectives --- should really be done via the morphology, like the nouns"
He is a fatter politician than the other guy.
greatest  A * (^DEGREE) = superlative
               @(PRED great).
               "is atype important here?"


greater  A * (^DEGREE) = comparative
               { @(PRED great)
               (^ATYPE) = attributive
               | (^ATYPE) = predicative
               (^ PRED)='great <(^ OBL-COMP)>' "wie man das mit dem optionalen Argument macht? - kann man sich nochmal anschauen"
               }.

great   A * (^DEGREE) = positive
               { @(PRED great)
               (^ATYPE) = attributive
               | (^ATYPE) = predicative
               (^ PRED)='great <(^OBL-COMP)>'
               }.

small 	  A * @(PRED small)
              (^DEGREE) = positive.

smart 	  A * @(PRED smart). 

grey 	  A * @(PRED grey).

Italian   A * @(PRED italian); ETC.

"not the revised semantics"

big 	  A * @(PRED big)
	      @(LLCLOSURE %mc796)
@(LLATOM %mc790 s::(ADJUNCT $ ^) e)
@(LLATOM %mc791 s::(ADJUNCT $ ^) t)
@(LLIMP %mc792 %mc790 %mc791)
@(LLATOM %mc793 s::(ADJUNCT $ ^) e)
@(LLATOM %mc794 s::(ADJUNCT $ ^) t)
@(LLIMP %mc795 %mc793 %mc794)
@(LLIMP %mc796 %mc792 %mc795)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc797)
@(GLUE-MEANING %mc796 %mc797)
@(NOSCOPE %mc796).

black 	  A * @(PRED black)
	      @(LLCLOSURE %mc796)
@(LLATOM %mc790 s::(ADJUNCT $ ^) e)
@(LLATOM %mc791 s::(ADJUNCT $ ^) t)
@(LLIMP %mc792 %mc790 %mc791)
@(LLATOM %mc793 s::(ADJUNCT $ ^) e)
@(LLATOM %mc794 s::(ADJUNCT $ ^) t)
@(LLIMP %mc795 %mc793 %mc794)
@(LLIMP %mc796 %mc792 %mc795)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc797)
@(GLUE-MEANING %mc796 %mc797)
@(NOSCOPE %mc796).

scottish  A * @(PRED scottish)
	      @(LLCLOSURE %mc796)
@(LLATOM %mc790 s::(ADJUNCT $ ^) e)
@(LLATOM %mc791 s::(ADJUNCT $ ^) t)
@(LLIMP %mc792 %mc790 %mc791)
@(LLATOM %mc793 s::(ADJUNCT $ ^) e)
@(LLATOM %mc794 s::(ADJUNCT $ ^) t)
@(LLIMP %mc795 %mc793 %mc794)
@(LLIMP %mc796 %mc792 %mc795)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc797)
@(GLUE-MEANING %mc796 %mc797)
@(NOSCOPE %mc796).

trustworthy A * @(PRED trustworthy)
		  @(LLCLOSURE %mc820)
@(LLATOM %mc814 s::(ADJUNCT $ ^) e)
@(LLATOM %mc815 s::(ADJUNCT $ ^) t)
@(LLIMP %mc816 %mc814 %mc815)
@(LLATOM %mc817 s::(ADJUNCT $ ^) e)
@(LLATOM %mc818 s::(ADJUNCT $ ^) t)
@(LLIMP %mc819 %mc817 %mc818)
@(LLIMP %mc820 %mc816 %mc819)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc821)
@(GLUE-MEANING %mc820 %mc821)
@(NOSCOPE %mc820).

alleged   A * @(PRED alleged)
	      @(LLCLOSURE %mc796)
@(LLATOM %mc790 s::(ADJUNCT $ ^) e)
@(LLATOM %mc791 s::(ADJUNCT $ ^) t)
@(LLIMP %mc792 %mc790 %mc791)
@(LLATOM %mc793 s::(ADJUNCT $ ^) e)
@(LLATOM %mc794 s::(ADJUNCT $ ^) t)
@(LLIMP %mc795 %mc793 %mc794)
@(LLIMP %mc796 %mc792 %mc795)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc797)
@(GLUE-MEANING %mc796 %mc797)
@(NOSCOPE %mc796).

former 	  A * @(PRED former)
	      @(LLCLOSURE %mc796)
@(LLATOM %mc790 s::(ADJUNCT $ ^) e)
@(LLATOM %mc791 s::(ADJUNCT $ ^) t)
@(LLIMP %mc792 %mc790 %mc791)
@(LLATOM %mc793 s::(ADJUNCT $ ^) e)
@(LLATOM %mc794 s::(ADJUNCT $ ^) t)
@(LLIMP %mc795 %mc793 %mc794)
@(LLIMP %mc796 %mc792 %mc795)
@(CONCAT lam `( Q `, lam `( X `, merge `( drs `(  `[  `]  `,  `[ pred `( %stem `, X `)  `]  `)  `, app `( Q `, X `)  `)  `)  `)  %mc797)
@(GLUE-MEANING %mc796 %mc797)
@(NOSCOPE %mc796).


"adverbs --- should really be done via the morphology, like the nouns"

quickly   ADV * @(PRED quickly). 

very 	  ADV * @(PRED very).


"comparison constructions"

than      CComp * (^PRED) = 'than<(^OBJ)>'
                  "(^DEGREE) =c comparative." "da muss man noch schauen wie.."
                  ((OBL-COMP ^) DEGREE) =c comparative.
                  "(^ ADJUNCT $ DEGREE) =c comparative"                         "funktioniert nicht mit he is a greater politican than..."

as        CComp * (^PRED) = 'as<(^OBJ)>'
                  (^DEGREE) ~=c comparative
                  (^DEGREE) ~=c superlative;
          ADVComp * @(PRED as)
                  (^DEGREE) ~=c comparative
                  (^DEGREE) ~=c superlative.


"prepositions"

by 	  P * @(PREP by). 

to 	  P * @(PREP to); 
	  PARTinf * (^ VFORM) =c inf.

on 	  P * @(PREP on). 

in 	  P * @(PREP in). 

with 	  P * @(PREP with)
	  @(PREP-SEM with). 


"auxiliaries"

"was 	  AUX * @(TENSE past)
            { @(PROG -_)
              @(PERF -_) |
             (^ TNS-ASP PROG)
            }
		{ (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg."

is 	  AUX * @(TENSE pres)
		{ (^ SUBJ PERS) = 1
                | (^ SUBJ PERS) = 3
                }
                (^ SUBJ NUM) = sg.

"pronouns (not complete)"

I 	  PRON * @(PRON I 1 sg pers) 
		 @(CASE nom).

You	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

you	PRON * {@(PRON you 2 sg pers)
	       |@(PRON you 2 pl pers)}.

He 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

he 	  PRON * @(PRON he 3 sg pers)
		 @(CASE nom).

She 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

she 	  PRON * @(PRON she 3 sg pers)
		 @(CASE nom).

it	  PRON * @(PRON it 3 sg pers). 

We 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

we 	  PRON * @(PRON we 1 pl pers)
		 @(CASE nom).

They 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom). 

they 	  PRON * @(PRON they 3 pl pers)
		 @(CASE nom).

My 	  PRON * @(POSS-PRON I sg 1).   "'I' or 'my' ??"

my 	  PRON * @(POSS-PRON I sg 1).

his 	  PRON * @(POSS-PRON he sg 3).

Her 	  PRON * {@(PRON she sg 3 pers)
		    |@(POSS-PRON she sg 3)}.

her 	  PRON * @(PRON her 3 sg pers).

Him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).

him 	  PRON * @(PRON he 3 sg pers)
		 @(CASE acc).



"expletive"
There   PRON *   (^PRON-TYPE) = expl_
	             (^PRON-FORM) = it
	             {(^NUM) =sg |(^NUM) = pl}.

"relative"
who PRON *      (^PRON-TYPE) = rel
                (^PRON-FORM) = who
                (^PRED) = 'PRO'
                "(^NUM)".


"determiners"

the 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +        "encoded as det-type in inness"
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc846)
@(LLATOM %mc838 s::^ e)
@(LLATOM %mc839 s::^ t)
@(LLIMP %mc840 %mc838 %mc839)
@(LLATOM %mc841 s::^ e)
@(LLATOM %mc842 %q t)
@(LLIMP %mc843 %mc841 %mc842)
@(LLATOM %mc844 %q t)
@(LLIMP %mc845 %mc843 %mc844)
@(LLIMP %mc846 %mc840 %mc845)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc847)
@(GLUE-MEANING %mc846 %mc847)
@(NOSCOPE %mc846).

The 	  D *
          @(SPEC-DET-PRED the)
          (^DEF) = +
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc846)
@(LLATOM %mc838 s::^ e)
@(LLATOM %mc839 s::^ t)
@(LLIMP %mc840 %mc838 %mc839)
@(LLATOM %mc841 s::^ e)
@(LLATOM %mc842 %q t)
@(LLIMP %mc843 %mc841 %mc842)
@(LLATOM %mc844 %q t)
@(LLIMP %mc845 %mc843 %mc844)
@(LLIMP %mc846 %mc840 %mc845)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc847)
@(GLUE-MEANING %mc846 %mc847)
@(NOSCOPE %mc846).


a 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc866)
@(LLATOM %mc858 s::^ e)
@(LLATOM %mc859 s::^ t)
@(LLIMP %mc860 %mc858 %mc859)
@(LLATOM %mc861 s::^ e)
@(LLATOM %mc862 %q t)
@(LLIMP %mc863 %mc861 %mc862)
@(LLATOM %mc864 %q t)
@(LLIMP %mc865 %mc863 %mc864)
@(LLIMP %mc866 %mc860 %mc865)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc867)
@(GLUE-MEANING %mc866 %mc867).


an 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc866)
@(LLATOM %mc858 s::^ e)
@(LLATOM %mc859 s::^ t)
@(LLIMP %mc860 %mc858 %mc859)
@(LLATOM %mc861 s::^ e)
@(LLATOM %mc862 %q t)
@(LLIMP %mc863 %mc861 %mc862)
@(LLATOM %mc864 %q t)
@(LLIMP %mc865 %mc863 %mc864)
@(LLIMP %mc866 %mc860 %mc865)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc867)
@(GLUE-MEANING %mc866 %mc867).
	
A 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc866)
@(LLATOM %mc858 s::^ e)
@(LLATOM %mc859 s::^ t)
@(LLIMP %mc860 %mc858 %mc859)
@(LLATOM %mc861 s::^ e)
@(LLATOM %mc862 %q t)
@(LLIMP %mc863 %mc861 %mc862)
@(LLATOM %mc864 %q t)
@(LLIMP %mc865 %mc863 %mc864)
@(LLIMP %mc866 %mc860 %mc865)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc867)
@(GLUE-MEANING %mc866 %mc867).

An 	  D * @(SPEC-DET-PRED a)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc866)
@(LLATOM %mc858 s::^ e)
@(LLATOM %mc859 s::^ t)
@(LLIMP %mc860 %mc858 %mc859)
@(LLATOM %mc861 s::^ e)
@(LLATOM %mc862 %q t)
@(LLIMP %mc863 %mc861 %mc862)
@(LLATOM %mc864 %q t)
@(LLIMP %mc865 %mc863 %mc864)
@(LLIMP %mc866 %mc860 %mc865)
@(CONCAT lam `( P `, lam `( Q `, merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, merge `( app `( P `, X `)  `, app `( Q `, X `)  `)  `)  `)  `)  %mc867)
@(GLUE-MEANING %mc866 %mc867).



more  D * (^DEF) = - "this indefinite only marks plurals"
          (^NUM) = pl
          (^DEGREE) = comparative. "marks the NP as comparative to allow CPComps to apply"

More  D * (^DEF) = - "this indefinite only marks plurals"
          (^NUM) = pl
          (^DEGREE) = comparative. "marks the NP as comparative to allow CPComps to apply"


"changed to spec-quant"
every 	  D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc906)
@(LLATOM %mc898 s::^ e)
@(LLATOM %mc899 s::^ t)
@(LLIMP %mc900 %mc898 %mc899)
@(LLATOM %mc901 s::^ e)
@(LLATOM %mc902 %q t)
@(LLIMP %mc903 %mc901 %mc902)
@(LLATOM %mc904 %q t)
@(LLIMP %mc905 %mc903 %mc904)
@(LLIMP %mc906 %mc900 %mc905)
@(CONCAT lam `( P `, lam `( Q `, drs `(  `[  `]  `,  `[ imp `( merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( P `, X `)  `)  `, app `( Q `, X `)  `)  `]  `)  `)  `)  %mc907)
@(GLUE-MEANING %mc906 %mc907).

Every 	   D * @(SPEC-QUANT-PRED every)
               @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars" 
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q) 
	      @(LLCLOSURE %mc906)
@(LLATOM %mc898 s::^ e)
@(LLATOM %mc899 s::^ t)
@(LLIMP %mc900 %mc898 %mc899)
@(LLATOM %mc901 s::^ e)
@(LLATOM %mc902 %q t)
@(LLIMP %mc903 %mc901 %mc902)
@(LLATOM %mc904 %q t)
@(LLIMP %mc905 %mc903 %mc904)
@(LLIMP %mc906 %mc900 %mc905)
@(CONCAT lam `( P `, lam `( Q `, drs `(  `[  `]  `,  `[ imp `( merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( P `, X `)  `)  `, app `( Q `, X `)  `)  `]  `)  `)  `)  %mc907)
@(GLUE-MEANING %mc906 %mc907).


" new quantifiers"

some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

Some D * @(SPEC-QUANT-PRED some)
	      (^ DEF) = -
	      (^ NUM) = pl
 	      @(QUANT-SCOPE ^ %q).

"preliminary semantics for all, copied from every"
"also for Fracas Testsuite"
"EX: All mice are animals"
all 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      @(LLCLOSURE %mc906)
@(LLATOM %mc898 s::^ e)
@(LLATOM %mc899 s::^ t)
@(LLIMP %mc900 %mc898 %mc899)
@(LLATOM %mc901 s::^ e)
@(LLATOM %mc902 %q t)
@(LLIMP %mc903 %mc901 %mc902)
@(LLATOM %mc904 %q t)
@(LLIMP %mc905 %mc903 %mc904)
@(LLIMP %mc906 %mc900 %mc905)
@(CONCAT lam `( P `, lam `( Q `, drs `(  `[  `]  `,  `[ imp `( merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( P `, X `)  `)  `, app `( Q `, X `)  `)  `]  `)  `)  `)  %mc907)
@(GLUE-MEANING %mc906 %mc907).

All 	  D * @(SPEC-QUANT-PRED all)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = - "this indefinite only marks singulars"
	      (^ NUM) = pl
	      @(QUANT-SCOPE ^ %q)
	      @(LLCLOSURE %mc906)
@(LLATOM %mc898 s::^ e)
@(LLATOM %mc899 s::^ t)
@(LLIMP %mc900 %mc898 %mc899)
@(LLATOM %mc901 s::^ e)
@(LLATOM %mc902 %q t)
@(LLIMP %mc903 %mc901 %mc902)
@(LLATOM %mc904 %q t)
@(LLIMP %mc905 %mc903 %mc904)
@(LLIMP %mc906 %mc900 %mc905)
@(CONCAT lam `( P `, lam `( Q `, drs `(  `[  `]  `,  `[ imp `( merge `( drs `(  `[ X `]  `,  `[  `]  `)  `, app `( P `, X `)  `)  `, app `( Q `, X `)  `)  `]  `)  `)  `)  %mc907)
@(GLUE-MEANING %mc906 %mc907).


"each"
Each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q).

each D *  @(SPEC-QUANT-PRED each)
          @(SPEC-QUANT-TYPE universal)
	      (^ DEF) = -
	      (^ NUM) = sg
 	      @(QUANT-SCOPE ^ %q).

"complementizers"

that  C * (^COMP-FORM) = that. 


"conjunctions"

and 	  CONJ * @(COORD-FORM %stem);
	  CONJnp * @(COORD-FORM %stem) @(NUM pl).

or 	  CONJ * @(COORD-FORM %stem);
	  CONJnp * @(COORD-FORM %stem) @(NUM pl).


"punctuation, now with some functional information"

. 	  PERIOD * (^ STMT-TYPE) = declarative. 

, 	  COMMA * . 

! 	  EXCL * (^ STMT-TYPE) = exclamation. 




----

GLUE   BASIC   TEMPLATES (1.0)

   LLIMP(N L R) = (N ANT) = L
	  (N CONS) = R.
	      
   LLATOM(N L T) = (N RESOURCE) = L
	  (N TYPE) = T.

   LLCLOSURE(G) = G $ (g::* GLUE).

   GLUE-MEANING(R M) = 
	  (R MEANING) = M.

  NOSCOPE(G) = (G NOSCOPE) = +.  

   NAME-SCOPE(UP NAME) =
   %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT| PREDLINK}+ ^)
   (%name FIN) =c +
   NAME  = (s::%name SIT)
   (s::^ QUANT-SCOPE) = NAME.

     QUANT-SCOPE(UP NAME) =
  	  %name = ({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT | PREDLINK}+ ^) "PREDLINK added so determiners are compatible eg. 'Mary is a dog'"
  	  (s::%name EV TYPE) =c eventuality
  	  NAME = (s::%name SIT)
  	  (s::^ QUANT-SCOPE) = NAME.

" Why does the below not work?
   QUANT-SCOPE(UP NAME) =
	  NAME = s::({SUBJ | OBJ | OBJ2 | XCOMP | OBL-TO | OBL-AG | OBL | ADJUNCT | PREDLINK}+ ^)
	  (NAME EV TYPE) =c eventuality
	  (s::^ QUANT-SCOPE) = (NAME SIT).
	  "

   ATTITUDE = (s::^ SIT) = %s
   	      (s::^ EV TYPE) = eventuality
	  {
	    (^ ROOT)
	    @TENSE-CLOSURE
	   |
	    ~[(^ ROOT)]
	    }.
	  
   EVENT(REL) =
	  (s::^ EV TYPE) = eventuality
	  (s::^ SIT) = %s
	  @(LLCLOSURE %mc940)
@(LLATOM %mc938 (s::^ EV) v)
@(LLATOM %mc939 (s::^ EV) t)
@(LLIMP %mc940 %mc938 %mc939)
@(CONCAT lam `( V `, drs `(  `[  `]  `,  `[ pred `( REL `, V `)  `]  `)  `)  %mc941)
@(GLUE-MEANING %mc940 %mc941)	  @(LLCLOSURE %mc948)
@(LLATOM %mc942 (s::^ EV) v)
@(LLATOM %mc943 (s::^ EV) t)
@(LLIMP %mc944 %mc942 %mc943)
@(LLATOM %mc945 %s s)
@(LLATOM %mc946 %s t)
@(LLIMP %mc947 %mc945 %mc946)
@(LLIMP %mc948 %mc944 %mc947)
@(CONCAT lam `( V `, lam `( S `, merge `( drs `(  `[ E `]  `,  `[ rel `( partOf `, E `, S `)  `]  `)  `, app `( V `, E `)  `)  `)  `)  %mc949)
@(GLUE-MEANING %mc948 %mc949)	  { 
	    (^ ROOT)
	    @TENSE-CLOSURE
	   |
	    ~[(^ ROOT)]}.

   PREP-SEM(P) =
             {
	     %scope = (s::(ADJUNCT ^) EV)
	     (%scope TYPE) =c eventuality
	    @(LLCLOSURE %mc960)
@(LLATOM %mc950 %scope v)
@(LLATOM %mc951 s::^ t)
@(LLIMP %mc952 %mc950 %mc951)
@(LLATOM %mc953 %scope v)
@(LLATOM %mc954 %scope t)
@(LLIMP %mc955 %mc953 %mc954)
@(LLATOM %mc956 %scope v)
@(LLATOM %mc957 %scope t)
@(LLIMP %mc958 %mc956 %mc957)
@(LLIMP %mc959 %mc955 %mc958)
@(LLIMP %mc960 %mc952 %mc959)
@(CONCAT lam `( U `, lam `( V `, lam `( E `, merge `( drs `(  `[  `]  `,  `[  `]  `)  `, merge `( app `( U `, E `)  `, app `( V `, E `)  `)  `)  `)  `)  `)  %mc961)
@(GLUE-MEANING %mc960 %mc961)	    @(LLCLOSURE %mc966)
@(LLATOM %mc962 s::(^OBJ) e)
@(LLATOM %mc963 %scope v)
@(LLATOM %mc964 s::^ t)
@(LLIMP %mc965 %mc963 %mc964)
@(LLIMP %mc966 %mc962 %mc965)
@(CONCAT lam `( Y `, lam `( X `, drs `(  `[  `]  `,  `[ rel `( P `, X `, Y `)  `]  `)  `)  `)  %mc967)
@(GLUE-MEANING %mc966 %mc967)	    |
	    %scope = s::(ADJUNCT ^)
	    (%scope TYPE) =c entity
	    @(LLCLOSURE %mc978)
@(LLATOM %mc968 s::(ADJUNCT ^) e)
@(LLATOM %mc969 s::^ t)
@(LLIMP %mc970 %mc968 %mc969)
@(LLATOM %mc971 s::(ADJUNCT ^) e)
@(LLATOM %mc972 %scope t)
@(LLIMP %mc973 %mc971 %mc972)
@(LLATOM %mc974 s::(ADJUNCT ^) e)
@(LLATOM %mc975 %scope t)
@(LLIMP %mc976 %mc974 %mc975)
@(LLIMP %mc977 %mc973 %mc976)
@(LLIMP %mc978 %mc970 %mc977)
@(CONCAT lam `( U `, lam `( V `, lam `( E `, merge `( drs `(  `[  `]  `,  `[  `]  `)  `, merge `( app `( U `, E `)  `, app `( V `, E `)  `)  `)  `)  `)  `)  %mc979)
@(GLUE-MEANING %mc978 %mc979)
@(NOSCOPE %mc978)	    @(LLCLOSURE %mc984)
@(LLATOM %mc980 s::(^OBJ) e)
@(LLATOM %mc981 s::(ADJUNCT ^) e)
@(LLATOM %mc982 s::^ t)
@(LLIMP %mc983 %mc981 %mc982)
@(LLIMP %mc984 %mc980 %mc983)
@(CONCAT lam `( Y `, lam `( X `, drs `(  `[  `]  `,  `[ rel `( P `, X `, Y `)  `]  `)  `)  `)  %mc985)
@(GLUE-MEANING %mc984 %mc985)	     }.

 TENSE-CLOSURE = %tense = (s::^ TEMP-REF EVAL)
 @(LLCLOSURE %mc990)
@(LLATOM %mc986 %tense s)
@(LLATOM %mc987 %tense t)
@(LLIMP %mc988 %mc986 %mc987)
@(LLATOM %mc989 s::^ t)
@(LLIMP %mc990 %mc988 %mc989)
@(CONCAT lam `( P `, merge `( drs `(  `[ T `]  `,  `[ eq `( T `, now `)  `]  `)  `, app `( P `, T `)  `)  `)  %mc991)
@(GLUE-MEANING %mc990 %mc991).

   "Templates for argument structure. Need to be separate to avoid trouble with local names"
   ARG1(ARG) =
       @(LLCLOSURE %mc1000)
@(LLATOM %mc992 (s::^ EV) v)
@(LLATOM %mc993 (s::^ EV) t)
@(LLIMP %mc994 %mc992 %mc993)
@(LLATOM %mc995 s::ARG e)
@(LLATOM %mc996 (s::^ EV) v)
@(LLATOM %mc997 (s::^ EV) t)
@(LLIMP %mc998 %mc996 %mc997)
@(LLIMP %mc999 %mc995 %mc998)
@(LLIMP %mc1000 %mc994 %mc999)
@(CONCAT lam `( V `, lam `( X `, lam `( E `, merge `( app `( V `, E `)  `, drs `(  `[  `]  `,  `[ rel `( arg1 `, E `, X `)  `]  `)  `)  `)  `)  `)  %mc1001)
@(GLUE-MEANING %mc1000 %mc1001)
@(NOSCOPE %mc1000).

   ARG2(ARG) =
       @(LLCLOSURE %mc1010)
@(LLATOM %mc1002 (s::^ EV) v)
@(LLATOM %mc1003 (s::^ EV) t)
@(LLIMP %mc1004 %mc1002 %mc1003)
@(LLATOM %mc1005 s::ARG e)
@(LLATOM %mc1006 (s::^ EV) v)
@(LLATOM %mc1007 (s::^ EV) t)
@(LLIMP %mc1008 %mc1006 %mc1007)
@(LLIMP %mc1009 %mc1005 %mc1008)
@(LLIMP %mc1010 %mc1004 %mc1009)
@(CONCAT lam `( V `, lam `( X `, lam `( E `, merge `( app `( V `, E `)  `, drs `(  `[  `]  `,  `[ rel `( arg2 `, E `, X `)  `]  `)  `)  `)  `)  `)  %mc1011)
@(GLUE-MEANING %mc1010 %mc1011)
@(NOSCOPE %mc1010).

   ARG3(ARG) =
       @(LLCLOSURE %mc1020)
@(LLATOM %mc1012 (s::^ EV) v)
@(LLATOM %mc1013 (s::^ EV) t)
@(LLIMP %mc1014 %mc1012 %mc1013)
@(LLATOM %mc1015 s::ARG e)
@(LLATOM %mc1016 (s::^ EV) v)
@(LLATOM %mc1017 (s::^ EV) t)
@(LLIMP %mc1018 %mc1016 %mc1017)
@(LLIMP %mc1019 %mc1015 %mc1018)
@(LLIMP %mc1020 %mc1014 %mc1019)
@(CONCAT lam `( V `, lam `( X `, lam `( E `, merge `( app `( V `, E `)  `, drs `(  `[  `]  `,  `[ rel `( arg3 `, E `, X `)  `]  `)  `)  `)  `)  `)  %mc1021)
@(GLUE-MEANING %mc1020 %mc1021)
@(NOSCOPE %mc1020).



----

